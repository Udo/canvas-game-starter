{"version":3,"file":"GifSprite.mjs","sources":["../../src/gif/GifSprite.ts"],"sourcesContent":["import { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { Sprite, type SpriteOptions } from '../scene/sprite/Sprite';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\nimport { GifSource } from './GifSource';\n\nimport type { SCALE_MODE } from '../rendering/renderers/shared/texture/const';\n\n/**\n * Optional module to import to decode and play animated GIFs.\n * @example\n * import { Assets } from 'pixi.js';\n * import { GifSprite } from 'pixi.js/gif';\n *\n * const source = await Assets.load('example.gif');\n * const gif = new GifSprite({ source });\n * @namespace gif\n */\n\n/**\n * Default options for all GifSprite objects.\n * @memberof gif\n */\ninterface GifSpriteOptions extends Omit<SpriteOptions, 'texture'>\n{\n    /** Source to the GIF frame and animation data */\n    source: GifSource;\n    /** Whether to start playing right away */\n    autoPlay?: boolean;\n    /**\n     * Scale Mode to use for the texture\n     * @type {PIXI.SCALE_MODE}\n     */\n    scaleMode?: SCALE_MODE;\n    /** To enable looping */\n    loop?: boolean;\n    /** Speed of the animation */\n    animationSpeed?: number;\n    /** Set to `false` to manage updates yourself */\n    autoUpdate?: boolean;\n    /** The completed callback, optional */\n    onComplete?: null | (() => void);\n    /** The loop callback, optional */\n    onLoop?: null | (() => void);\n    /** The frame callback, optional */\n    onFrameChange?: null | ((currentFrame: number) => void);\n    /** Fallback FPS if GIF contains no time information */\n    fps?: number;\n}\n\n/**\n * Runtime object to play animated GIFs. This object is similar to an AnimatedSprite.\n * It support playback (seek, play, stop) as well as animation speed and looping.\n * @memberof gif\n * @see Thanks to {@link https://github.com/matt-way/gifuct-js/ gifuct-js}\n */\nclass GifSprite extends Sprite\n{\n    /**\n     * Default options for all GifSprite objects.\n     * @property {PIXI.SCALE_MODE} [scaleMode='linear'] - Scale mode to use for the texture.\n     * @property {boolean} [loop=true] - To enable looping.\n     * @property {number} [animationSpeed=1] - Speed of the animation.\n     * @property {boolean} [autoUpdate=true] - Set to `false` to manage updates yourself.\n     * @property {boolean} [autoPlay=true] - To start playing right away.\n     * @property {Function} [onComplete=null] - The completed callback, optional.\n     * @property {Function} [onLoop=null] - The loop callback, optional.\n     * @property {Function} [onFrameChange=null] - The frame callback, optional.\n     * @property {number} [fps=30] - Fallback FPS if GIF contains no time information.\n     */\n    public static defaultOptions: Omit<GifSpriteOptions, 'source'> = {\n        scaleMode: 'linear',\n        fps: 30,\n        loop: true,\n        animationSpeed: 1,\n        autoPlay: true,\n        autoUpdate: true,\n        onComplete: null,\n        onFrameChange: null,\n        onLoop: null,\n    };\n\n    /**\n     * The speed that the animation will play at. Higher is faster, lower is slower.\n     * @default 1\n     */\n    public animationSpeed = 1;\n\n    /**\n     * Whether or not the animate sprite repeats after playing.\n     * @default true\n     */\n    public loop = true;\n\n    /**\n     * User-assigned function to call when animation finishes playing. This only happens\n     * if loop is set to `false`.\n     * @example\n     * animation.onComplete = () => {\n     *   // finished!\n     * };\n     */\n    public onComplete?: () => void;\n\n    /**\n     * User-assigned function to call when animation changes which texture is being rendered.\n     * @example\n     * animation.onFrameChange = () => {\n     *   // updated!\n     * };\n     */\n    public onFrameChange?: (currentFrame: number) => void;\n\n    /**\n     * User-assigned function to call when `loop` is true, and animation is played and\n     * loops around to start again. This only happens if loop is set to `true`.\n     * @example\n     * animation.onLoop = () => {\n     *   // looped!\n     * };\n     */\n    public onLoop?: () => void;\n\n    /** The total duration of animation in milliseconds. */\n    public readonly duration: number = 0;\n\n    /** Whether to play the animation after constructing. */\n    public readonly autoPlay: boolean = true;\n\n    /** Collection of frame to render. */\n    private _source: GifSource;\n\n    /** Dirty means the image needs to be redrawn. Set to `true` to force redraw. */\n    public dirty = false;\n\n    /** The current frame number (zero-based index). */\n    private _currentFrame = 0;\n\n    /** `true` uses PIXI.Ticker.shared to auto update animation time.*/\n    private _autoUpdate = false;\n\n    /** `true` if the instance is currently connected to PIXI.Ticker.shared to auto update animation time. */\n    private _isConnectedToTicker = false;\n\n    /** If animation is currently playing. */\n    private _playing = false;\n\n    /** Current playback position in milliseconds. */\n    private _currentTime = 0;\n\n    /**\n     * @param source - Source, default options will be used.\n     */\n    constructor(source: GifSource);\n\n    /**\n     * @param options - Options for the GifSprite\n     */\n    constructor(options: GifSpriteOptions);\n\n    /** @ignore */\n    constructor(...args: [GifSource] | [GifSpriteOptions])\n    {\n        const options = args[0] instanceof GifSource ? { source: args[0] } : args[0];\n\n        // Get the options, apply defaults\n        const {\n            scaleMode,\n            source,\n            fps,\n            loop,\n            animationSpeed,\n            autoPlay,\n            autoUpdate,\n            onComplete,\n            onFrameChange,\n            onLoop,\n            ...rest\n        } = Object.assign({},\n            GifSprite.defaultOptions,\n            options\n        );\n\n        super({ texture: Texture.EMPTY, ...rest });\n\n        // Handle rerenders\n        this.onRender = () => this._updateFrame();\n\n        this.texture = source.textures[0];\n\n        this.duration = source.frames[source.frames.length - 1].end;\n        this._source = source;\n        this._playing = false;\n        this._currentTime = 0;\n        this._isConnectedToTicker = false;\n        Object.assign(this, {\n            fps,\n            loop,\n            animationSpeed,\n            autoPlay,\n            autoUpdate,\n            onComplete,\n            onFrameChange,\n            onLoop,\n        });\n\n        // Draw the first frame\n        this.currentFrame = 0;\n        if (autoPlay)\n        {\n            this.play();\n        }\n    }\n\n    /** Stops the animation. */\n    public stop(): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        this._playing = false;\n        if (this._autoUpdate && this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    }\n\n    /** Plays the animation. */\n    public play(): void\n    {\n        if (this._playing)\n        {\n            return;\n        }\n\n        this._playing = true;\n        if (this._autoUpdate && !this._isConnectedToTicker)\n        {\n            Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isConnectedToTicker = true;\n        }\n\n        // If were on the last frame and stopped, play should resume from beginning\n        if (!this.loop && this.currentFrame === this._source.frames.length - 1)\n        {\n            this._currentTime = 0;\n        }\n    }\n\n    /**\n     * Get the current progress of the animation from 0 to 1.\n     * @readonly\n     */\n    public get progress(): number\n    {\n        return this._currentTime / this.duration;\n    }\n\n    /** `true` if the current animation is playing */\n    public get playing(): boolean\n    {\n        return this._playing;\n    }\n\n    /**\n     * Updates the object transform for rendering. You only need to call this\n     * if the `autoUpdate` property is set to `false`.\n     * @param ticker - Ticker instance\n     */\n    public update(ticker: Ticker): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        const elapsed = this.animationSpeed * ticker.deltaTime / Ticker.targetFPMS;\n        const currentTime = this._currentTime + elapsed;\n        const localTime = currentTime % this.duration;\n\n        const localFrame = this._source.frames.findIndex((frame) =>\n            frame.start <= localTime && frame.end > localTime);\n\n        if (currentTime >= this.duration)\n        {\n            if (this.loop)\n            {\n                this._currentTime = localTime;\n                this._updateFrameIndex(localFrame);\n                this.onLoop?.();\n            }\n            else\n            {\n                this._currentTime = this.duration;\n                this._updateFrameIndex(this.totalFrames - 1);\n                this.onComplete?.();\n                this.stop();\n            }\n        }\n        else\n        {\n            this._currentTime = localTime;\n            this._updateFrameIndex(localFrame);\n        }\n    }\n\n    /** Redraw the current frame, is necessary for the animation to work when */\n    private _updateFrame(): void\n    {\n        if (!this.dirty)\n        {\n            return;\n        }\n\n        // Update the current frame\n        this.texture = this._source.frames[this._currentFrame].texture;\n\n        // Mark as clean\n        this.dirty = false;\n    }\n\n    /**\n     * Whether to use PIXI.Ticker.shared to auto update animation time.\n     * @default true\n     */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.update, this);\n                this._isConnectedToTicker = false;\n            }\n            else if (this._autoUpdate && !this._isConnectedToTicker && this._playing)\n            {\n                Ticker.shared.add(this.update, this);\n                this._isConnectedToTicker = true;\n            }\n        }\n    }\n\n    /** Set the current frame number */\n    get currentFrame(): number\n    {\n        return this._currentFrame;\n    }\n    set currentFrame(value: number)\n    {\n        this._updateFrameIndex(value);\n        this._currentTime = this._source.frames[value].start;\n    }\n\n    /** Instance of the data, contains frame textures */\n    get source(): GifSource\n    {\n        return this._source;\n    }\n\n    /**\n     * Internally handle updating the frame index\n     * @param value\n     */\n    private _updateFrameIndex(value: number): void\n    {\n        if (value < 0 || value >= this.totalFrames)\n        {\n            throw new Error(`Frame index out of range, expecting 0 to ${this.totalFrames}, got ${value}`);\n        }\n        if (this._currentFrame !== value)\n        {\n            this._currentFrame = value;\n            this.dirty = true;\n            this.onFrameChange?.(value);\n        }\n    }\n\n    /** Get the total number of frame in the GIF. */\n    get totalFrames(): number\n    {\n        return this._source.totalFrames;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param destroyData - Destroy the data, cannot be used again.\n     */\n    public destroy(destroyData: boolean = false): void\n    {\n        this.stop();\n        super.destroy();\n\n        if (destroyData)\n        {\n            this._source.destroy();\n        }\n\n        const forceClear = null as any;\n\n        this._source = forceClear;\n        this.onComplete = forceClear;\n        this.onFrameChange = forceClear;\n        this.onLoop = forceClear;\n    }\n\n    /**\n     * Cloning the animation is a useful way to create a duplicate animation.\n     * This maintains all the properties of the original animation but allows\n     * you to control playback independent of the original animation.\n     * If you want to create a simple copy, and not control independently,\n     * then you can simply create a new Sprite, e.g. `const sprite = new Sprite(animation.texture)`.\n     *\n     * The clone will be flagged as `dirty` to immediatly trigger an update\n     */\n    public clone(): GifSprite\n    {\n        const clone = new GifSprite({\n            source: this._source,\n            autoUpdate: this._autoUpdate,\n            loop: this.loop,\n            autoPlay: this.autoPlay,\n            scaleMode: this.texture.source.scaleMode,\n            animationSpeed: this.animationSpeed,\n            onComplete: this.onComplete,\n            onFrameChange: this.onFrameChange,\n            onLoop: this.onLoop,\n        });\n\n        clone.dirty = true;\n\n        return clone;\n    }\n}\n\nexport { GifSprite };\nexport type { GifSpriteOptions };\n"],"names":[],"mappings":"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"}
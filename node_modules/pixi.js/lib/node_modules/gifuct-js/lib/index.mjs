import '../../../_virtual/_commonjsHelpers.mjs';
import { __exports as lib } from '../../../_virtual/index.mjs';
import '../../../_virtual/gif.mjs';
import '../../../_virtual/index2.mjs';
import '../../../_virtual/uint8.mjs';
import '../../../_virtual/deinterlace.mjs';
import '../../../_virtual/lzw.mjs';
import { __exports as gif } from '../../../_virtual/gif2.mjs';
import { __exports as lib$1 } from '../../../_virtual/index3.mjs';
import { __exports as uint8 } from '../../../_virtual/uint82.mjs';
import { __exports as deinterlace } from '../../../_virtual/deinterlace2.mjs';
import { __exports as lzw } from '../../../_virtual/lzw2.mjs';

"use strict";
Object.defineProperty(lib, "__esModule", {
  value: true
});
var decompressFrames_1 = lib.decompressFrames = decompressFrame_1 = lib.decompressFrame = parseGIF_1 = lib.parseGIF = void 0;
var _gif = _interopRequireDefault(gif);
var _jsBinarySchemaParser = lib$1;
var _uint = uint8;
var _deinterlace = deinterlace;
var _lzw = lzw;
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
var parseGIF = function parseGIF2(arrayBuffer) {
  var byteData = new Uint8Array(arrayBuffer);
  return (0, _jsBinarySchemaParser.parse)((0, _uint.buildStream)(byteData), _gif["default"]);
};
var parseGIF_1 = lib.parseGIF = parseGIF;
var generatePatch = function generatePatch2(image) {
  var totalPixels = image.pixels.length;
  var patchData = new Uint8ClampedArray(totalPixels * 4);
  for (var i = 0; i < totalPixels; i++) {
    var pos = i * 4;
    var colorIndex = image.pixels[i];
    var color = image.colorTable[colorIndex] || [0, 0, 0];
    patchData[pos] = color[0];
    patchData[pos + 1] = color[1];
    patchData[pos + 2] = color[2];
    patchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0;
  }
  return patchData;
};
var decompressFrame = function decompressFrame2(frame, gct, buildImagePatch) {
  if (!frame.image) {
    console.warn("gif frame does not have associated image.");
    return;
  }
  var image = frame.image;
  var totalPixels = image.descriptor.width * image.descriptor.height;
  var pixels = (0, _lzw.lzw)(image.data.minCodeSize, image.data.blocks, totalPixels);
  if (image.descriptor.lct.interlaced) {
    pixels = (0, _deinterlace.deinterlace)(pixels, image.descriptor.width);
  }
  var resultImage = {
    pixels,
    dims: {
      top: frame.image.descriptor.top,
      left: frame.image.descriptor.left,
      width: frame.image.descriptor.width,
      height: frame.image.descriptor.height
    }
  };
  if (image.descriptor.lct && image.descriptor.lct.exists) {
    resultImage.colorTable = image.lct;
  } else {
    resultImage.colorTable = gct;
  }
  if (frame.gce) {
    resultImage.delay = (frame.gce.delay || 10) * 10;
    resultImage.disposalType = frame.gce.extras.disposal;
    if (frame.gce.extras.transparentColorGiven) {
      resultImage.transparentIndex = frame.gce.transparentColorIndex;
    }
  }
  if (buildImagePatch) {
    resultImage.patch = generatePatch(resultImage);
  }
  return resultImage;
};
var decompressFrame_1 = lib.decompressFrame = decompressFrame;
var decompressFrames = function decompressFrames2(parsedGif, buildImagePatches) {
  return parsedGif.frames.filter(function(f) {
    return f.image;
  }).map(function(f) {
    return decompressFrame(f, parsedGif.gct, buildImagePatches);
  });
};
decompressFrames_1 = lib.decompressFrames = decompressFrames;

export { decompressFrame_1 as decompressFrame, decompressFrames_1 as decompressFrames, lib as default, parseGIF_1 as parseGIF };
//# sourceMappingURL=index.mjs.map

{"version":3,"file":"RenderGroupSystem.js","sources":["../../../src/scene/container/RenderGroupSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from './bounds/Bounds';\nimport { clearList } from './utils/clearList';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer, RenderPipes } from '../../rendering/renderers/types';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @memberof rendering\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        // we need to save the parent and renderGroupParent, so we can restore them later\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        // we set the transforms and parents to null, so we can render the container without any transforms\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        let originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        //  this._assignTop(container.renderGroup, null);\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        this._updateCachedRenderGroups(container.renderGroup, null);\n\n        this._updateRenderGroups(container.renderGroup);\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        // now return the transforms back to normal..\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n\n    private _updateCachedRenderGroups(renderGroup: RenderGroup, closestCacheAsTexture: RenderGroup | null): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            // early out as nothing further needs to be updated!\n            if (!renderGroup.updateCacheTexture) return;\n\n            closestCacheAsTexture = renderGroup;\n        }\n\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n\n        // now check the cacheAsTexture stuff...\n        for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)\n        {\n            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        }\n\n        renderGroup.invalidateMatrices();\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            if (renderGroup.textureNeedsUpdate)\n            {\n                // lets get the texture ready for rendering\n                // but the rendering will not happen until the renderGroup is rendered!\n                // We also want to know now, what the bounds of the texture will be.\n                // as if the texture changes, we need to invalidate the parent render group!\n                const bounds = renderGroup.root.getLocalBounds();\n\n                bounds.ceil();\n\n                const lastTexture = renderGroup.texture;\n\n                if (renderGroup.texture)\n                {\n                    TexturePool.returnTexture(renderGroup.texture);\n                }\n\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n\n                renderGroup.texture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    resolution,\n                    antialias\n                );\n\n                renderGroup._textureBounds ||= new Bounds();\n                renderGroup._textureBounds.copyFrom(bounds);\n\n                if (lastTexture !== renderGroup.texture)\n                {\n                    if (renderGroup.renderGroupParent)\n                    {\n                        renderGroup.renderGroupParent.structureDidChange = true;\n                    }\n                }\n            }\n        }\n        else if (renderGroup.texture)\n        {\n            TexturePool.returnTexture(renderGroup.texture);\n            renderGroup.texture = null;\n        }\n    }\n\n    private _updateRenderGroups(renderGroup: RenderGroup): void\n    {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n\n        renderGroup.runOnRender(renderer);\n\n        renderGroup.instructionSet.renderPipes = renderPipes;\n\n        if (!renderGroup.structureDidChange)\n        {\n            // phase 1 - validate all the renderables\n            validateRenderables(renderGroup, renderPipes);\n        }\n        else\n        {\n            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n        }\n\n        // phase 2 - update all the transforms\n        // including updating the renderables..\n        updateRenderGroupTransforms(renderGroup);\n\n        if (renderGroup.structureDidChange)\n        {\n            renderGroup.structureDidChange = false;\n\n            // build the renderables\n            this._buildInstructions(renderGroup, renderer);\n        }\n        else\n        {\n            // update remaining renderables\n            this._updateRenderables(renderGroup);\n        }\n\n        // reset the renderables to update\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n\n        // upload all the things!\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n\n        // early out if it's a texture and it hasn't changed!\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n        }\n    }\n\n    private _updateRenderables(renderGroup: RenderGroup)\n    {\n        const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n        for (let i = 0; i < index; i++)\n        {\n            const container = list[i];\n\n            if (container.didViewUpdate)\n            {\n                renderGroup.updateRenderable(container as ViewContainer);\n            }\n        }\n\n        clearList(list, index);\n    }\n\n    /**\n     * @param renderGroup\n     * @param renderPipes\n     * @deprecated since 8.3.0\n     */\n    private _buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes): void;\n    private _buildInstructions(renderGroup: RenderGroup, renderer: Renderer): void;\n    private _buildInstructions(renderGroup: RenderGroup, rendererOrPipes: RenderPipes | Renderer): void\n    {\n    // rebuild the scene graph based on layers...\n        const root = renderGroup.root;\n        const instructionSet = renderGroup.instructionSet;\n\n        instructionSet.reset();\n\n        // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n        const renderer = (rendererOrPipes as Renderer).renderPipes\n            ? (rendererOrPipes as Renderer)\n            : (rendererOrPipes as RenderPipes).batch.renderer;\n        const renderPipes = renderer.renderPipes;\n\n        // TODO add some events / runners for build start\n        renderPipes.batch.buildStart(instructionSet);\n        renderPipes.blendMode.buildStart();\n        renderPipes.colorMask.buildStart();\n\n        if (root.sortableChildren)\n        {\n            root.sortChildren();\n        }\n\n        root.collectRenderablesWithEffects(instructionSet, renderer, null);\n\n        // TODO add some events / runners for build end\n        renderPipes.batch.buildEnd(instructionSet);\n        renderPipes.blendMode.buildEnd(instructionSet);\n    }\n}\n\n"],"names":["Matrix","executeInstructions","TexturePool","Bounds","validateRenderables","clearList","updateRenderGroupTransforms","ExtensionType"],"mappings":"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"}
{"version":3,"file":"RenderLayer.js","sources":["../../../src/scene/layers/RenderLayer.ts"],"sourcesContent":["import { type InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type Renderer } from '../../rendering/renderers/types';\nimport { warn } from '../../utils/logging/warn';\nimport { type Bounds } from '../container/bounds/Bounds';\nimport { Container } from '../container/Container';\n\nimport type EventEmitter from 'eventemitter3';\n// TODO make it clear render layer cannot have 'filters'\n\n/**\n * Options for configuring a RenderLayer.\n * @memberof scene\n */\nexport interface RenderLayerOptions\n{\n    /**\n     * If true, the layer's children will be sorted by zIndex before rendering\n     * If false, you can manually sort the children using sortRenderLayerChildren when ever you need!\n     * @default false\n     */\n    sortableChildren?: boolean;\n\n    /**\n     * Custom sort function to sort layer children. Default sorts by zIndex.\n     * @param a - First container to compare\n     * @param b - Second container to compare\n     * @returns Negative if a should render before b, positive if b should render before a\n     */\n    sortFunction?: (a: Container, b: Container) => number;\n}\n\n/*\n * Here we are essentially hiding the Container API even though this class extends a Container.\n * This is just so it fits into the current architecture. When users use a RenderLayer,\n * the Container properties will be hidden from them, as they don't do anything in renderLayers.\n */\ntype ContainerKeys = keyof Container;\ntype PartialContainerKeys = Exclude<ContainerKeys,\n'parent' | 'didChange' | '_updateFlags' | keyof EventEmitter | 'parentRenderLayer' |\n'destroyed' | 'layerParentId' | 'sortableChildren' | 'getFastGlobalBounds'\n>;\nexport type IRenderLayer = Omit<RenderLayerClass, PartialContainerKeys>;\n\n/**\n * The RenderLayer API provides a way to control the rendering order of objects independently\n * of their logical parent-child relationships in the scene graph.\n * This allows developers to decouple how objects are transformed\n * (via their logical parent) from how they are rendered on the screen.\n *\n * ### Key Concepts\n *\n * #### RenderLayers Control Rendering Order:\n * - RenderLayers define where in the render stack objects are drawn,\n * but they do not affect an object's transformations (e.g., position, scale, rotation) or logical hierarchy.\n * - RenderLayers can be added anywhere in the scene graph.\n *\n * #### Logical Parenting Remains Unchanged:\n * - Objects still have a logical parent for transformations via addChild.\n * - Assigning an object to a layer does not reparent it.\n *\n * #### Explicit Control:\n * - Developers assign objects to layers using renderLayer.add and remove them using renderLayer.remove.\n * ---\n * ### API Details\n *\n * #### 1. Creating a RenderLayer\n * A RenderLayer is a lightweight object responsible for controlling render order.\n * It has no children or transformations of its own\n * but can be inserted anywhere in the scene graph to define its render position.\n * ```js\n * const layer = new RenderLayer();\n * app.stage.addChild(layer); // Insert the layer into the scene graph\n * ```\n *\n * #### 2. Adding Objects to a Layer\n * Use renderLayer.add to assign an object to a layer.\n * This overrides the object's default render order defined by its logical parent.\n * ```js\n * const rect = new PIXI.Graphics();\n * container.addChild(rect);    // Add to logical parent\n * layer.attach(rect);      // Control render order via the layer\n * ```\n *\n * #### 3. Removing Objects from a Layer\n * To stop an object from being rendered in the layer, use remove.\n * ```js\n * layer.remove(rect); // Stop rendering rect via the layer\n * ```\n * When an object is removed from its logical parent (removeChild), it is automatically removed from the layer.\n *\n * #### 4. Re-Adding Objects to Layers\n * If an object is re-added to a logical parent, it does not automatically reassign itself to the layer.\n * Developers must explicitly reassign it.\n * ```js\n * container.addChild(rect);    // Logical parent\n * layer.attach(rect);      // Explicitly reassign to the layer\n * ```\n *\n * #### 5. Layer Position in Scene Graph\n * A layer's position in the scene graph determines its render priority relative to other layers and objects.\n * Layers can be inserted anywhere in the scene graph.\n * ```js\n * const backgroundLayer = new RenderLayer();\n * const uiLayer = new RenderLayer();\n *\n * app.stage.addChild(backgroundLayer);\n * app.stage.addChild(world);\n * app.stage.addChild(uiLayer);\n * ```\n * This is a new API and therefore considered experimental at this stage.\n * While the core is pretty robust, there are still a few tricky issues we need to tackle.\n * However, even with the known issues below, we believe this API is incredibly useful!\n *\n * Known issues:\n *  - Interaction may not work as expected since hit testing does not account for the visual render order created by layers.\n *    For example, if an object is visually moved to the front via a layer, hit testing will still use its original position.\n *  - RenderLayers and their children must all belong to the same renderGroup to work correctly\n * @memberof scene\n * @class RenderLayer\n * @extends null\n */\nexport class RenderLayerClass extends Container\n{\n    /**\n     * Default options for RenderLayer instances\n     * @property {boolean} sortableChildren - If true, layer children will be automatically sorted each render.\n     * Default false.\n     * @property {Function} sortFunction - Function used to sort layer children. Default sorts by zIndex.\n     */\n    public static defaultOptions: RenderLayerOptions = {\n        sortableChildren: false,\n        sortFunction: (a, b) => a.zIndex - b.zIndex,\n    };\n\n    /** Function used to sort layer children if sortableChildren is true */\n    public sortFunction: (a: Container, b: Container) => number;\n\n    /** List of objects to be rendered by this layer */\n    public renderLayerChildren: Container[] = [];\n\n    /**\n     * Creates a new RenderLayer instance\n     * @param options - Configuration options for the RenderLayer\n     * @param {boolean} [options.sortableChildren=false] - If true, layer children will be automatically sorted each render\n     * @param {Function} [options.sortFunction] - Custom function to sort layer children. Default sorts by zIndex\n     */\n    constructor(options: RenderLayerOptions = {})\n    {\n        options = { ...RenderLayerClass.defaultOptions, ...options };\n\n        super();\n\n        this.sortableChildren = options.sortableChildren;\n        this.sortFunction = options.sortFunction;\n    }\n\n    /**\n     * Add an Container to this render layer. The Container will be rendered as part of this layer\n     * while maintaining its original parent in the scene graph.\n     * If the Container already belongs to a layer, it will be removed from the old layer before being added to this one.\n     * @param children - The Container(s) to add to this layer\n     */\n    public attach<U extends Container[]>(...children: U): U[0]\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.parentRenderLayer)\n            {\n                if (child.parentRenderLayer === this) continue;\n\n                child.parentRenderLayer.detach(child);\n            }\n\n            this.renderLayerChildren.push(child);\n\n            child.parentRenderLayer = this;\n\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            if (renderGroup)\n            {\n                renderGroup.structureDidChange = true;\n            }\n        }\n\n        return children[0];\n    }\n\n    /**\n     * Remove an Container from this render layer. The Container will no longer be rendered\n     * as part of this layer but maintains its original parent.\n     * @param children - The Container(s) to remove from this layer\n     */\n    public detach<U extends Container[]>(...children: U): U[0]\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            const index = this.renderLayerChildren.indexOf(child);\n\n            if (index !== -1)\n            {\n                this.renderLayerChildren.splice(index, 1);\n            }\n\n            child.parentRenderLayer = null;\n\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            if (renderGroup)\n            {\n                renderGroup.structureDidChange = true;\n            }\n        }\n\n        return children[0];\n    }\n\n    /** Remove all objects from this render layer. */\n    public detachAll()\n    {\n        const layerChildren = this.renderLayerChildren;\n\n        for (let i = 0; i < layerChildren.length; i++)\n        {\n            layerChildren[i].parentRenderLayer = null;\n        }\n\n        this.renderLayerChildren.length = 0;\n    }\n\n    public override collectRenderables(instructionSet: InstructionSet, renderer: Renderer, _currentLayer: RenderLayerClass\n    ): void\n    {\n        const layerChildren = this.renderLayerChildren;\n        const length = layerChildren.length;\n\n        if (this.sortableChildren)\n        {\n            this.sortRenderLayerChildren();\n        }\n\n        for (let i = 0; i < length; i++)\n        {\n            if (!layerChildren[i].parent)\n            {\n                // eslint-disable-next-line max-len\n                warn('Container must be added to both layer and scene graph. Layers only handle render order - the scene graph is required for transforms (addChild)',\n                    layerChildren[i]);\n            }\n\n            layerChildren[i].collectRenderables(instructionSet, renderer, this);\n        }\n    }\n\n    /**\n     * Sort the layer's children using the defined sort function.\n     * Will be called each render if sortableChildren is true.\n     * Otherwise can call this manually.\n     */\n    public sortRenderLayerChildren()\n    {\n        this.renderLayerChildren.sort(this.sortFunction);\n    }\n\n    public override _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        _currentLayer: RenderLayerClass,\n    ): void\n    {\n        if (!factorRenderLayers) return;\n\n        const children = this.renderLayerChildren;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            children[i]._getGlobalBoundsRecursive(true, bounds, this);\n        }\n    }\n}\n\nexport const RenderLayer = RenderLayerClass as {\n    new (options?: RenderLayerOptions): IRenderLayer;\n};\n"],"names":["Container","warn"],"mappings":"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"}
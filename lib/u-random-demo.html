<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>U-Random Demo</title>
    <style>
        :root {
            --space: 8px;
            --radius: 5px;
            
            --gray: #6c757d;
            --gray-bg: #f5f5f5;
            --blue: #007acc;
            --green: #28a745;
            --white: white;
            --dark: #333;
            
            --max-width: 1400px;
            --sidebar: 400px;
        }
        
        * { box-sizing: border-box; }
        
        body { 
            font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: var(--max-width);
            margin: 0 auto;
            padding: var(--space);
            background: var(--gray-bg);
        }
        
        .container { 
            background: var(--white);
            padding: calc(var(--space) * 1.5);
            border-radius: var(--radius);
        }
        
        .main-layout { 
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: calc(var(--space) * 1.5);
        }
        
        .api-column { 
            background: var(--gray-bg);
            padding: var(--space);
            border-radius: var(--radius);
            border-left: 4px solid var(--green);
        }
        
        h1 { 
            color: var(--dark);
            text-align: center;
            margin-bottom: calc(var(--space) * 1.5);
            grid-column: 1 / -1;
        }
        
        h2 { 
            color: var(--gray);
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: var(--space);
            margin-top: calc(var(--space) * 1.5);
        }
        
        .demo-section { 
            margin: var(--space) 0;
            padding: var(--space);
            background: var(--gray-bg);
            border-radius: var(--radius);
            border-left: 4px solid var(--blue);
        }
        
        .controls, .input-group { 
            display: flex;
            gap: var(--space);
            margin: 15px 0;
        }
        
        .controls { flex-wrap: wrap; }
        .input-group { align-items: center; }
        .feature-grid { display: grid; gap: var(--space); margin: var(--space) 0; }
        
        button { 
            background: var(--blue);
            color: var(--white);
            border: none;
            padding: var(--space) var(--space);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        button:hover { filter: brightness(0.9); }
        button:disabled { background: #ccc; cursor: not-allowed; }
        
        input[type="text"], input[type="number"], input[type="range"] { 
            padding: var(--space);
            border: 1px solid #ddd;
            border-radius: var(--radius);
        }
        
        input[type="number"] {
            width: 80px;
        }
        
        input[type="range"] {
            flex: 1;
        }
        
        .status, .code-example { 
            font-family: monospace;
            padding: var(--space);
            border-radius: var(--radius);
            margin: var(--space) 0;
        }
        
        .status { 
            background: var(--dark);
            color: #0f0;
            white-space: pre-wrap;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .code-example { 
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            overflow-x: auto;
            margin: var(--space) 0;
        }
        
        .highlight { color: #68d391; }
        .keyword { color: #fbb6ce; }
        .string { color: #fbd38d; }
        
        .api-section { margin: 15px 0; }
        .api-section h3 { 
            color: var(--green);
            margin: 0 0 var(--space) 0;
        }
        
        .api-method { 
            font-family: monospace;
            margin: 3px 0;
            color: var(--gray);
        }
        
        .api-method .method-name { color: var(--blue); font-weight: bold; }
        .api-method .return-type { color: #6f42c1; }
        .api-method .param { color: #e83e8c; }
        
        .api-description {
            margin: var(--space) 0;
        }
        
        .api-options {
            color: var(--gray);
        }
        
        .help-text {
            color: var(--gray);
            margin: var(--space) 0;
        }
        
        .code-comment {
            color: #68d391;
        }
        
        .color-box { 
            display: inline-block; 
            width: 30px; 
            height: 30px; 
            margin: 5px; 
            border: 1px solid #000; 
            border-radius: var(--radius);
        }
        
        canvas { 
            border: 1px solid #ddd; 
            border-radius: var(--radius);
            margin: var(--space) 0;
        }
        
        @media (max-width: 1200px) {
            .main-layout { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>U-Random Demo</h1>
        
        <div class="main-layout">
            <div class="demo-column">
                <h2>Basic Random Generation</h2>
                <div class="demo-section">
                    <div class="input-group">
                        <label>Seed:</label>
                        <input type="number" id="basic-seed" value="12345" min="0">
                        <label>Position:</label>
                        <input type="number" id="basic-position" value="0" min="0">
                        <button onclick="generateBasicRandom()">Generate</button>
                    </div>
                    <div class="status" id="basic-output"></div>
                    <div class="help-text">Same seed + position = same result every time</div>
                </div>

                <div class="demo-section">
                    <div class="controls">
                        <button onclick="demonstrateSeries()">Create Series</button>
                        <button onclick="generateFromSeries()">Get Next 10</button>
                        <button onclick="resetSeries()">Reset</button>
                    </div>
                    <div class="status" id="series-output"></div>
                </div>
            </div>

            <div class="api-column">
                <h2>Overview</h2>
                
                <div class="api-section">
                    <div class="api-method"><span class="method-name">get_noise_01</span>(<span class="param">position, seed</span>) → <span class="return-type">number</span></div>
                    <div class="api-description">
                        Generates deterministic random value between 0-1 using Squirrel3 algorithm
                    </div>
                    <div class="api-method"><span class="method-name">RandomSeries</span>(<span class="param">seed</span>) → <span class="return-type">object</span></div>
                    <div class="api-description">
                        Creates a random number generator with automatic position tracking
                    </div>
                </div>

                <div class="api-section">
                    <h3>RandomSeries Methods</h3>
                    <div class="api-method"><span class="method-name">get()</span> → <span class="return-type">number</span></div>
                    <div class="api-description">Get next value 0-1</div>
                    
                    <div class="api-method"><span class="method-name">get_float</span>(<span class="param">from, to</span>) → <span class="return-type">number</span></div>
                    <div class="api-description">Get next value in range</div>
                    
                    <div class="api-method"><span class="method-name">get_int</span>(<span class="param">from, to</span>) → <span class="return-type">number</span></div>
                    <div class="api-description">Get next integer in range</div>
                </div>

                <div class="api-section">
                    <h3>Examples</h3>
                    <pre class="code-example">
<span class="code-comment">// Consistent random value</span>
<span class="keyword">const</span> value = <span class="highlight">get_noise_01</span>(<span class="string">100</span>, <span class="string">42</span>);

<span class="code-comment">// Random series generator</span>
<span class="keyword">const</span> rng = <span class="keyword">new</span> <span class="highlight">RandomSeries</span>(<span class="string">123</span>);
<span class="keyword">const</span> next = rng.<span class="highlight">get</span>();
<span class="keyword">const</span> dice = rng.<span class="highlight">get_int</span>(<span class="string">1</span>, <span class="string">6</span>);
</pre>
                </div>
            </div>
        </div>

        </div>

        <div class="main-layout">
            <div class="demo-column">
                <h2>Noise Visualization</h2>
                <div class="demo-section">
                    <h3>1D Noise Pattern</h3>
                    <canvas id="noise-canvas" width="400" height="150"></canvas>
                    <div class="input-group">
                        <label>Seed:</label>
                        <input type="range" id="noise-seed" min="0" max="1000" value="100" oninput="updateNoise()">
                        <span id="noise-seed-value">100</span>
                        <label>Width:</label>
                        <input type="range" id="noise-width" min="50" max="500" value="200" oninput="updateNoise()">
                        <span id="noise-width-value">200</span>
                    </div>
                </div>

                <div class="demo-section">
                    <h3>2D Noise Pattern</h3>
                    <canvas id="noise2d-canvas" width="200" height="200"></canvas>
                    <div class="input-group">
                        <label>Seed:</label>
                        <input type="range" id="noise2d-seed" min="0" max="1000" value="200" oninput="updateNoise2D()">
                        <span id="noise2d-seed-value">200</span>
                        <label>Scale:</label>
                        <input type="range" id="noise2d-scale" min="1" max="20" value="5" oninput="updateNoise2D()">
                        <span id="noise2d-scale-value">5</span>
                    </div>
                </div>
            </div>

            <div class="api-column">
                <h2>Noise Patterns</h2>
                
                <div class="api-section">
                    <h3>Noise Generation</h3>
                    <div class="api-description">
                        The noise function produces deterministic pseudo-random values based on position and seed. Perfect for procedural generation where consistency is required.
                    </div>
                </div>

                <div class="api-section">
                    <h3>Usage Examples</h3>
                    <pre class="code-example">
<span class="code-comment">// Generate terrain height</span>
<span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="string">0</span>; x < width; x++) {
  <span class="keyword">const</span> height = <span class="highlight">get_noise_01</span>(x, terrainSeed);
  drawTerrain(x, height * maxHeight);
}

<span class="code-comment">// 2D texture generation</span>
<span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="string">0</span>; y < height; y++) {
  <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="string">0</span>; x < width; x++) {
    <span class="keyword">const</span> pos = x + y * width;
    <span class="keyword">const</span> value = <span class="highlight">get_noise_01</span>(pos, seed);
    setPixel(x, y, value);
  }
}
</pre>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="demo-column">
                <h2>Distribution Analysis</h2>
                <div class="demo-section">
                    <canvas id="histogram-canvas" width="400" height="250"></canvas>
                    <div class="input-group">
                        <label>Samples:</label>
                        <input type="number" id="analysis-samples" value="10000" min="1000" max="100000" step="1000">
                        <label>Seed:</label>
                        <input type="number" id="analysis-seed" value="777" min="0">
                        <button onclick="analyzeDistribution()">Analyze</button>
                    </div>
                    <div class="status" id="distribution-stats"></div>
                </div>
            </div>

            <div class="api-column">
                <h2>Quality Analysis</h2>
                
                <div class="api-section">
                    <h3>Statistical Properties</h3>
                    <div class="api-description">
                        The Squirrel3 algorithm produces well-distributed random values with good statistical properties. Analysis shows uniform distribution across the 0-1 range.
                    </div>
                </div>

                <div class="api-section">
                    <h3>Expected Values</h3>
                    <pre class="code-example">
<span class="code-comment">// Statistical expectations</span>
Mean: ~<span class="string">0.5</span>
Standard Deviation: ~<span class="string">0.289</span>
Range: <span class="string">0.0</span> to <span class="string">1.0</span>

<span class="code-comment">// Testing randomness quality</span>
<span class="keyword">const</span> samples = <span class="string">10000</span>;
<span class="keyword">let</span> sum = <span class="string">0</span>;
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="string">0</span>; i < samples; i++) {
  sum += <span class="highlight">get_noise_01</span>(i, seed);
}
<span class="keyword">const</span> mean = sum / samples;
</pre>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="demo-column">
                
                <div class="demo-section">
                    <h3>Procedural Terrain</h3>
                    <canvas id="terrain-canvas" width="200" height="150"></canvas>
                    <div class="controls">
                        <button onclick="generateTerrain()">Generate Terrain</button>
                    </div>
                </div>

                <div class="demo-section">
                    <h3>Random Color Palette</h3>
                    <div style="display: flex; gap: 10px; align-items: flex-start;">
                        <canvas id="palette-canvas" width="200" height="150"></canvas>
                        <div id="palette-colors" style="padding-top:var(--space)"></div>
                    </div>
                    <div class="controls">
                        <button onclick="generatePalette()">Generate Palette</button>
                    </div>
                </div>

                <div class="demo-section">
                    <h3>Particle System</h3>
                    <canvas id="particles-canvas" width="200" height="150"></canvas>
                    <div class="controls">
                        <button onclick="startParticles()">Start</button>
                        <button onclick="stopParticles()">Stop</button>
                    </div>
                </div>
            </div>

            <div class="api-column">
                
                <div class="api-section">
                    <h3>Procedural Generation</h3>
                    <div class="api-description">
                        Use deterministic random values for consistent procedural content generation across multiple runs or sessions.
                    </div>
                </div>

                <div class="api-section">
                    <h3>Game Examples</h3>
                    <pre class="code-example">
<span class="code-comment">// Procedural terrain generation</span>
<span class="keyword">function</span> <span class="highlight">generateTerrain</span>(seed) {
  <span class="keyword">const</span> heights = [];
  <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="string">0</span>; x < width; x++) {
    <span class="keyword">let</span> height = <span class="string">0</span>;
    height += <span class="highlight">get_noise_01</span>(x * <span class="string">0.01</span>, seed) * <span class="string">0.5</span>;
    height += <span class="highlight">get_noise_01</span>(x * <span class="string">0.02</span>, seed + <span class="string">1</span>) * <span class="string">0.25</span>;
    heights.push(height);
  }
  <span class="keyword">return</span> heights;
}

<span class="code-comment">// Random enemy spawning</span>
<span class="keyword">const</span> rng = <span class="keyword">new</span> <span class="highlight">RandomSeries</span>(levelSeed);
<span class="keyword">const</span> enemyCount = rng.<span class="highlight">get_int</span>(<span class="string">5</span>, <span class="string">15</span>);
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="string">0</span>; i < enemyCount; i++) {
  <span class="keyword">const</span> x = rng.<span class="highlight">get_float</span>(<span class="string">0</span>, mapWidth);
  <span class="keyword">const</span> y = rng.<span class="highlight">get_float</span>(<span class="string">0</span>, mapHeight);
  spawnEnemy(x, y);
}
</pre>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="demo-column">
                <h2>Seed Comparison</h2>
                <div class="demo-section">
                    <canvas id="comparison-canvas" width="400" height="300"></canvas>
                    <div class="controls">
                        <button onclick="compareSeedsVisualization()">Compare Seeds</button>
                    </div>
                    <div class="help-text">Different seeds produce completely different but consistent sequences</div>
                </div>
            </div>

            <div class="api-column">
                <div class="api-section">
                    <h3>Reproducibility</h3>
                    <div class="api-description">
                        Seeds allow exact reproduction of random sequences. Critical for debugging, testing, and creating shareable content.
                    </div>
                </div>

                <div class="api-section">
                    <h3>Comparison Examples</h3>
                    <pre class="code-example">
<span class="code-comment">// Save and restore game state</span>
<span class="keyword">const</span> worldSeed = <span class="string">12345</span>;
<span class="keyword">const</span> world = <span class="highlight">generateWorld</span>(worldSeed);

<span class="code-comment">// Players can share seeds</span>
shareSeed(worldSeed);

<span class="code-comment">// Recreate exact same world</span>
<span class="keyword">const</span> sameWorld = <span class="highlight">generateWorld</span>(worldSeed);

<span class="code-comment">// Different seeds = different content</span>
<span class="keyword">const</span> world1 = <span class="highlight">generateWorld</span>(<span class="string">111</span>);
<span class="keyword">const</span> world2 = <span class="highlight">generateWorld</span>(<span class="string">222</span>);
</pre>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="demo-column">
                <h2>Seed Tree System</h2>
                <div class="demo-section">
                    <h3>Master Seed Generator</h3>
                    <div class="input-group">
                        <label>Master Seed:</label>
                        <input type="number" id="master-seed" value="42" min="0">
                        <button onclick="generateSeedTree()">Generate Tree</button>
                    </div>
                    <div class="status" id="seed-tree-output"></div>
                </div>

                <div class="demo-section">
                    <h3>Game World Preview</h3>
                    <canvas id="world-canvas" width="400" height="200"></canvas>
                    <div class="controls">
                        <button onclick="generateGameWorld()">Generate World</button>
                        <button onclick="addNewFeature()">Add Weather System</button>
                    </div>
                    <div class="help-text">Same master seed always produces identical worlds</div>
                </div>
            </div>

            <div class="api-column">
                <h2>Seed Tree Design</h2>
                
                <div class="api-section">
                    <h3>Hierarchical Generation</h3>
                    <div class="api-description">
                        A seed tree uses a master seed to generate deterministic sub-seeds for different game systems. This ensures consistency while allowing new features to be added later.
                    </div>
                </div>

                <div class="api-section">
                    <h3>Implementation Pattern</h3>
                    <pre class="code-example">
<span class="code-comment">// Master seed generates sub-seeds</span>
<span class="keyword">function</span> <span class="highlight">generateSubSeed</span>(masterSeed, feature) {
  <span class="keyword">const</span> featureHash = <span class="highlight">make_hash</span>(feature);
  <span class="keyword">return</span> <span class="highlight">get_noise_01</span>(featureHash, masterSeed) * <span class="string">0x7FFFFFFF</span>;
}

<span class="code-comment">// Use sub-seeds for different systems</span>
<span class="keyword">const</span> terrainSeed = <span class="highlight">generateSubSeed</span>(masterSeed, <span class="string">'terrain'</span>);
<span class="keyword">const</span> enemySeed = <span class="highlight">generateSubSeed</span>(masterSeed, <span class="string">'enemies'</span>);
<span class="keyword">const</span> lootSeed = <span class="highlight">generateSubSeed</span>(masterSeed, <span class="string">'loot'</span>);

<span class="code-comment">// New features use same master seed</span>
<span class="keyword">const</span> weatherSeed = <span class="highlight">generateSubSeed</span>(masterSeed, <span class="string">'weather'</span>);
</pre>
                </div>

            </div>
        </div>

        <div class="main-layout">
            <div class="demo-column">
                <h2>Quality Analysis</h2>
                <div class="demo-section">
                    <canvas id="quality-canvas" width="400" height="300"></canvas>
                    <div class="controls">
                        <button onclick="performQualityAnalysis()">Analyze Random Seed</button>
                    </div>
                    <div class="status" id="quality-output"></div>
                </div>
            </div>

            <div class="api-column">
                <h2>Quality Metrics</h2>
                
                <div class="api-section">
                    <h3>Statistical Tests</h3>
                    <div class="api-description">
                        Evaluates the randomness quality by measuring distribution uniformity, chi-square goodness of fit, and autocorrelation.
                    </div>
                </div>

                <div class="api-section">
                    <h3>Quality Indicators</h3>
                    <pre class="code-example">
<span class="code-comment">// Chi-square test for uniformity</span>
<span class="keyword">function</span> <span class="highlight">chiSquareTest</span>(samples, bins) {
  <span class="keyword">const</span> expected = samples / bins;
  <span class="keyword">let</span> chiSquare = <span class="string">0</span>;
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="string">0</span>; i < bins; i++) {
    <span class="keyword">const</span> diff = histogram[i] - expected;
    chiSquare += (diff * diff) / expected;
  }
  <span class="keyword">return</span> chiSquare;
}

<span class="code-comment">// Autocorrelation analysis</span>
<span class="keyword">const</span> lag1 = <span class="highlight">autocorrelation</span>(values, <span class="string">1</span>);
</pre>
                </div>
            </div>
        </div>
    </div>

    <script src="u-random.js"></script>
    <script>
        let currentSeries = null;
        let particleAnimation = null;

        // Utility functions for common patterns
        function getElement(id) {
            return document.getElementById(id);
        }

        function getIntValue(id) {
            return parseInt(getElement(id).value);
        }

        function updateTextContent(id, value) {
            getElement(id).textContent = value;
        }

        function getCanvasContext(canvasId) {
            const canvas = getElement(canvasId);
            const ctx = canvas.getContext('2d');
            return { canvas, ctx };
        }

        function clearCanvas(canvasId) {
            const { canvas, ctx } = getCanvasContext(canvasId);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return { canvas, ctx };
        }

        function log(message, outputId = 'basic-output') {
            const output = getElement(outputId);
            const timestamp = new Date().toLocaleTimeString();
            output.textContent += `[${timestamp}] ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }

        function clearOutput(outputId) {
            getElement(outputId).textContent = '';
        }

        function generateBasicRandom() {
            clearOutput('basic-output');
            const seed = getIntValue('basic-seed');
            const position = getIntValue('basic-position');
            
            const result = get_noise_01(position, seed);
            
            log(`get_noise_01(${position}, ${seed}) = ${result.toFixed(6)}`, 'basic-output');
            log(`Next values:`, 'basic-output');
            log(`Position ${position + 1}: ${get_noise_01(position + 1, seed).toFixed(6)}`, 'basic-output');
            log(`Position ${position + 2}: ${get_noise_01(position + 2, seed).toFixed(6)}`, 'basic-output');
            log(`Position ${position + 3}: ${get_noise_01(position + 3, seed).toFixed(6)}`, 'basic-output');
        }

        function demonstrateSeries() {
            const seed = getIntValue('basic-seed');
            currentSeries = new RandomSeries(seed);
            
            clearOutput('series-output');
            log(`Random series created with seed: ${seed}`, 'series-output');
            log(`Position: ${currentSeries.position}`, 'series-output');
        }

        function generateFromSeries() {
            if (!currentSeries) {
                demonstrateSeries();
            }
            
            clearOutput('series-output');
            log('Next 10 numbers from series:', 'series-output');
            for (let i = 0; i < 10; i++) {
                const value = currentSeries.get();
                log(`${i + 1}: ${value.toFixed(6)}`, 'series-output');
            }
            log(`Current position: ${currentSeries.position}`, 'series-output');
        }

        function resetSeries() {
            if (!currentSeries) return;
            const seed = currentSeries.seed;
            currentSeries = new RandomSeries(seed);
            clearOutput('series-output');
            log(`Series reset to seed: ${seed}`, 'series-output');
            log(`Position: ${currentSeries.position}`, 'series-output');
        }

        function updateNoise() {
            const seed = getIntValue('noise-seed');
            const width = getIntValue('noise-width');
            
            updateTextContent('noise-seed-value', seed);
            updateTextContent('noise-width-value', width);
            
            const { canvas, ctx } = clearCanvas('noise-canvas');
            
            // Draw grid lines
            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw noise curve
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let x = 0; x < width; x++) {
                const noise = get_noise_01(x, seed);
                const y = canvas.height - (noise * canvas.height);
                
                if (x === 0) {
                    ctx.moveTo(x * (canvas.width / width), y);
                } else {
                    ctx.lineTo(x * (canvas.width / width), y);
                }
            }
            ctx.stroke();
        }

        function updateNoise2D() {
            const seed = getIntValue('noise2d-seed');
            const scale = getIntValue('noise2d-scale');
            
            updateTextContent('noise2d-seed-value', seed);
            updateTextContent('noise2d-scale-value', scale);
            
            const { canvas, ctx } = getCanvasContext('noise2d-canvas');
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const position = (x * scale) + (y * scale * canvas.width);
                    const noise = get_noise_01(position, seed);
                    
                    const intensity = Math.floor(noise * 255);
                    const index = (y * canvas.width + x) * 4;
                    
                    imageData.data[index] = intensity;
                    imageData.data[index + 1] = intensity;
                    imageData.data[index + 2] = intensity;
                    imageData.data[index + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function analyzeDistribution() {
            const samples = getIntValue('analysis-samples');
            const seed = getIntValue('analysis-seed');
            
            const { canvas, ctx } = clearCanvas('histogram-canvas');
            const bins = 50;
            const histogram = new Array(bins).fill(0);
            
            let sum = 0;
            let min = 1;
            let max = 0;
            
            for (let i = 0; i < samples; i++) {
                const value = get_noise_01(i, seed);
                sum += value;
                min = Math.min(min, value);
                max = Math.max(max, value);
                
                const binIndex = Math.floor(value * bins);
                if (binIndex < bins) {
                    histogram[binIndex]++;
                }
            }
            
            const mean = sum / samples;
            
            let variance = 0;
            for (let i = 0; i < samples; i++) {
                const value = get_noise_01(i, seed);
                variance += Math.pow(value - mean, 2);
            }
            const stdDev = Math.sqrt(variance / samples);
            
            const maxCount = Math.max(...histogram);
            const barWidth = canvas.width / bins;
            const margin = 30;
            const plotHeight = canvas.height - 2 * margin;
            
            ctx.fillStyle = '#4ecdc4';
            for (let i = 0; i < bins; i++) {
                const barHeight = (histogram[i] / maxCount) * plotHeight;
                const x = i * barWidth;
                const y = canvas.height - margin - barHeight;
                
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }
            
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const meanX = mean * canvas.width;
            ctx.moveTo(meanX, margin);
            ctx.lineTo(meanX, canvas.height - margin);
            ctx.stroke();
            
            clearOutput('distribution-stats');
            log(`Distribution Analysis (${samples} samples):`, 'distribution-stats');
            log(`Mean: ${mean.toFixed(6)} (expected ~0.5)`, 'distribution-stats');
            log(`Std Dev: ${stdDev.toFixed(6)} (expected ~0.289)`, 'distribution-stats');
            log(`Min: ${min.toFixed(6)}`, 'distribution-stats');
            log(`Max: ${max.toFixed(6)}`, 'distribution-stats');
            log(`Range: ${(max - min).toFixed(6)}`, 'distribution-stats');
        }

        function generateTerrain() {
            const { canvas, ctx } = clearCanvas('terrain-canvas');
            const seed = Math.floor(Math.random() * 1000);
            
            const heights = [];
            for (let x = 0; x < canvas.width; x++) {
                let height = 0;
                height += get_noise_01(x * 0.01, seed) * 0.5;
                height += get_noise_01(x * 0.02, seed + 1) * 0.25;
                height += get_noise_01(x * 0.05, seed + 2) * 0.125;
                heights.push(height * canvas.height);
            }
            
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, Math.min(...heights.map(h => canvas.height - h)));
            
            ctx.fillStyle = '#4a5d23';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            for (let x = 0; x < canvas.width; x++) {
                ctx.lineTo(x, canvas.height - heights[x]);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
        }

        function generatePalette() {
            const { canvas, ctx } = clearCanvas('palette-canvas');
            const seed = Math.floor(Math.random() * 1000);
            
            const colorCount = 8;
            const colorWidth = canvas.width / colorCount;
            const colors = [];
            
            for (let i = 0; i < colorCount; i++) {
                const r = Math.floor(get_noise_01(i * 3, seed) * 255);
                const g = Math.floor(get_noise_01(i * 3 + 1, seed + 100) * 255);
                const b = Math.floor(get_noise_01(i * 3 + 2, seed + 200) * 255);
                
                const hex = '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
                colors.push(hex);
                
                ctx.fillStyle = hex;
                ctx.fillRect(i * colorWidth, 0, colorWidth, canvas.height);
            }
            
            const colorDisplay = getElement('palette-colors');
            colorDisplay.innerHTML = colors.map((color, i) => `${color}`).join('<br>');
        }

        function startParticles() {
            if (particleAnimation) return;
            
            const { canvas, ctx } = getCanvasContext('particles-canvas');
            const seed = Math.floor(Math.random() * 1000);
            const particles = [];
            
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: get_noise_01(i * 2, seed) * canvas.width,
                    y: get_noise_01(i * 2 + 1, seed + 100) * canvas.height,
                    vx: (get_noise_01(i * 3, seed + 200) - 0.5) * 2,
                    vy: (get_noise_01(i * 3 + 1, seed + 300) - 0.5) * 2,
                    color: `hsl(${get_noise_01(i, seed + 400) * 360}, 70%, 60%)`
                });
            }
            
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                particles.forEach(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    if (particle.x < 0 || particle.x > canvas.width) particle.vx *= -1;
                    if (particle.y < 0 || particle.y > canvas.height) particle.vy *= -1;
                    
                    particle.x = Math.max(0, Math.min(canvas.width, particle.x));
                    particle.y = Math.max(0, Math.min(canvas.height, particle.y));
                    
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                particleAnimation = requestAnimationFrame(animate);
            }
            
            animate();
        }

        function stopParticles() {
            if (particleAnimation) {
                cancelAnimationFrame(particleAnimation);
                particleAnimation = null;
            }
        }

        function compareSeedsVisualization() {
            const { canvas, ctx } = clearCanvas('comparison-canvas');
            const seeds = [42, 123, 456, 789];
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12'];
            
            // Draw grid lines
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw noise curves for each seed
            seeds.forEach((seed, seedIndex) => {
                ctx.strokeStyle = colors[seedIndex];
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let x = 0; x < canvas.width; x++) {
                    const noise = get_noise_01(x, seed);
                    const y = canvas.height - (noise * canvas.height);
                    
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            });
            
            // Draw legend
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            seeds.forEach((seed, index) => {
                ctx.fillStyle = colors[index];
                ctx.fillText(`Seed ${seed}`, 10 + index * 80, 20);
            });
        }

        function make_hash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        function generateSubSeed(masterSeed, feature) {
            const featureHash = make_hash(feature);
            return Math.floor(get_noise_01(featureHash, masterSeed) * 0x7FFFFFFF);
        }

        let currentSeedTree = {};
        let weatherEnabled = false;

        // Unified generator for 2D world elements
        function generate2DElements(canvasId, seed, config) {
            const { canvas, ctx } = getCanvasContext(canvasId);
            const rng = new RandomSeries(seed);
            
            if (config.position) {
                rng.position = config.position;
            }
            
            ctx.fillStyle = config.fillStyle;
            if (config.strokeStyle) {
                ctx.strokeStyle = config.strokeStyle;
                ctx.lineWidth = config.lineWidth || 1;
            }
            
            for (let i = 0; i < config.count; i++) {
                const x = rng.get_float(config.margin || 0, canvas.width - (config.margin || 0));
                const y = rng.get_float(config.margin || 0, canvas.height - (config.margin || 0));
                
                config.drawFunction(ctx, x, y, rng);
            }
        }

        // Drawing functions for different element types
        const drawFunctions = {
            circle: (ctx, x, y, radius = 6) => {
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
            },
            
            diamond: (ctx, x, y, size = 3) => {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(Math.PI / 4);
                ctx.fillRect(-size, -size, size * 2, size * 2);
                ctx.restore();
            },
            
            rectangle: (ctx, x, y, width = 8, height = 12) => {
                ctx.fillRect(x - width/2, y - height/2, width, height);
            },
            
            gridSquare: (ctx, x, y, size = 18, threshold = 0.7, rng) => {
                if (rng.get() > threshold) {
                    ctx.fillRect(x, y, size, size);
                }
            },
            
            weatherParticle: (ctx, x, y, rng) => {
                ctx.beginPath();
                ctx.arc(x, y, 1, 0, 2 * Math.PI);
                ctx.fill();
            },
            
            rainDrop: (ctx, x, y) => {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + 3, y + 15);
                ctx.stroke();
            }
        };

        function generateSeedTree() {
            const masterSeed = getIntValue('master-seed');
            
            currentSeedTree = {
                master: masterSeed,
                terrain: generateSubSeed(masterSeed, 'terrain'),
                enemies: generateSubSeed(masterSeed, 'enemies'),
                loot: generateSubSeed(masterSeed, 'loot'),
                npcs: generateSubSeed(masterSeed, 'npcs'),
                quests: generateSubSeed(masterSeed, 'quests')
            };
            
            if (weatherEnabled) {
                currentSeedTree.weather = generateSubSeed(masterSeed, 'weather');
            }
            
            clearOutput('seed-tree-output');
            log(`Master Seed: ${currentSeedTree.master}`, 'seed-tree-output');
            log(`├─ Terrain: ${currentSeedTree.terrain}`, 'seed-tree-output');
            log(`├─ Enemies: ${currentSeedTree.enemies}`, 'seed-tree-output');
            log(`├─ Loot: ${currentSeedTree.loot}`, 'seed-tree-output');
            log(`├─ NPCs: ${currentSeedTree.npcs}`, 'seed-tree-output');
            log(`├─ Quests: ${currentSeedTree.quests}`, 'seed-tree-output');
            
            if (weatherEnabled) {
                log(`└─ Weather: ${currentSeedTree.weather}`, 'seed-tree-output');
            }
            
            generateGameWorld();
        }

        function generateGameWorld() {
            if (!currentSeedTree.master) {
                generateSeedTree();
                return;
            }
            
            const { canvas, ctx } = clearCanvas('world-canvas');
            
            generateTerrain2D(ctx, currentSeedTree.terrain);
            generateEnemies2D(ctx, currentSeedTree.enemies);
            generateLoot2D(ctx, currentSeedTree.loot);
            generateNPCs2D(ctx, currentSeedTree.npcs);
            
            if (weatherEnabled && currentSeedTree.weather) {
                generateWeather2D(ctx, currentSeedTree.weather);
            }
        }

        function generateTerrain2D(ctx, seed) {
            const { canvas } = getCanvasContext('world-canvas');
            
            // Generate terrain blocks
            const terrainRng = new RandomSeries(seed);
            ctx.fillStyle = '#4a5d23';
            
            for (let x = 0; x < canvas.width; x += 20) {
                for (let y = 0; y < canvas.height; y += 20) {
                    drawFunctions.gridSquare(ctx, x, y, 18, 0.7, terrainRng);
                }
            }
            
            // Generate rock formations
            terrainRng.position = 1000;
            ctx.fillStyle = '#8B4513';
            
            for (let x = 0; x < canvas.width; x += 15) {
                for (let y = 0; y < canvas.height; y += 15) {
                    drawFunctions.gridSquare(ctx, x, y, 12, 0.85, terrainRng);
                }
            }
        }

        function generateEnemies2D(ctx, seed) {
            generate2DElements('world-canvas', seed, {
                count: 8,
                fillStyle: '#ff4444',
                margin: 10,
                drawFunction: (ctx, x, y) => drawFunctions.circle(ctx, x, y, 6)
            });
        }

        function generateLoot2D(ctx, seed) {
            generate2DElements('world-canvas', seed, {
                count: 12,
                fillStyle: '#ffdd44',
                margin: 5,
                drawFunction: (ctx, x, y) => drawFunctions.diamond(ctx, x, y, 3)
            });
        }

        function generateNPCs2D(ctx, seed) {
            generate2DElements('world-canvas', seed, {
                count: 5,
                fillStyle: '#4444ff',
                margin: 8,
                drawFunction: (ctx, x, y) => drawFunctions.rectangle(ctx, x, y, 8, 12)
            });
        }

        function generateWeather2D(ctx, seed) {
            const weatherRng = new RandomSeries(seed);
            const weatherType = weatherRng.get_int(0, 2);
            
            if (weatherType === 0) {
                // Snow
                generate2DElements('world-canvas', seed, {
                    count: 100,
                    fillStyle: 'rgba(200, 200, 255, 0.3)',
                    margin: 0,
                    drawFunction: (ctx, x, y) => drawFunctions.weatherParticle(ctx, x, y)
                });
            } else if (weatherType === 1) {
                // Rain
                generate2DElements('world-canvas', seed, {
                    count: 50,
                    strokeStyle: 'rgba(255, 255, 255, 0.6)',
                    lineWidth: 2,
                    margin: 0,
                    drawFunction: (ctx, x, y) => drawFunctions.rainDrop(ctx, x, y)
                });
            }
        }

        function addNewFeature() {
            weatherEnabled = true;
            generateSeedTree();
        }

        function performQualityAnalysis() {
            const seed = Math.floor(Math.random() * 10000);
            const samples = 10000;
            const bins = 20;
            
            clearOutput('quality-output');
            log(`Quality Analysis - Random Seed: ${seed}`, 'quality-output');
            
            const { canvas, ctx } = clearCanvas('quality-canvas');
            
            const values = [];
            const histogram = new Array(bins).fill(0);
            
            let sum = 0;
            let sumSquares = 0;
            
            for (let i = 0; i < samples; i++) {
                const value = get_noise_01(i, seed);
                values.push(value);
                sum += value;
                sumSquares += value * value;
                
                const binIndex = Math.floor(value * bins);
                if (binIndex < bins) {
                    histogram[binIndex]++;
                }
            }
            
            const mean = sum / samples;
            const variance = (sumSquares / samples) - (mean * mean);
            const stdDev = Math.sqrt(variance);
            
            const expected = samples / bins;
            let chiSquare = 0;
            for (let i = 0; i < bins; i++) {
                const diff = histogram[i] - expected;
                chiSquare += (diff * diff) / expected;
            }
            
            let autocorr1 = 0;
            for (let i = 1; i < values.length; i++) {
                autocorr1 += (values[i] - mean) * (values[i-1] - mean);
            }
            autocorr1 = autocorr1 / ((values.length - 1) * variance);
            
            const maxCount = Math.max(...histogram);
            const barWidth = canvas.width / bins;
            const margin = 40;
            const plotHeight = canvas.height - 2 * margin;
            
            ctx.fillStyle = '#4ecdc4';
            for (let i = 0; i < bins; i++) {
                const barHeight = (histogram[i] / maxCount) * plotHeight;
                const x = i * barWidth;
                const y = canvas.height - margin - barHeight;
                
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }
            
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const expectedLine = (expected / maxCount) * plotHeight;
            ctx.moveTo(0, canvas.height - margin - expectedLine);
            ctx.lineTo(canvas.width, canvas.height - margin - expectedLine);
            ctx.stroke();
            
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('Expected frequency', 10, 20);
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(120, 15);
            ctx.lineTo(140, 15);
            ctx.stroke();
            
            log(`Mean: ${mean.toFixed(6)} (expected: 0.5)`, 'quality-output');
            log(`Std Dev: ${stdDev.toFixed(6)} (expected: 0.289)`, 'quality-output');
            log(`Chi-Square: ${chiSquare.toFixed(2)} (expected: ~${bins})`, 'quality-output');
            log(`Autocorr(1): ${autocorr1.toFixed(6)} (expected: ~0)`, 'quality-output');
            
            const meanQuality = Math.abs(mean - 0.5) < 0.01 ? 'GOOD' : 'POOR';
            const stdQuality = Math.abs(stdDev - 0.289) < 0.01 ? 'GOOD' : 'POOR';
            const chiQuality = chiSquare < bins * 1.5 ? 'GOOD' : 'POOR';
            const autocorrQuality = Math.abs(autocorr1) < 0.05 ? 'GOOD' : 'POOR';
            
            log(`Quality Assessment:`, 'quality-output');
            log(`  Distribution: ${meanQuality}`, 'quality-output');
            log(`  Variance: ${stdQuality}`, 'quality-output');
            log(`  Uniformity: ${chiQuality}`, 'quality-output');
            log(`  Independence: ${autocorrQuality}`, 'quality-output');
        }

        document.addEventListener('DOMContentLoaded', function() {
            generateBasicRandom();
            updateNoise();
            updateNoise2D();
            generateTerrain();
            generatePalette();
            generateSeedTree();
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>U-Grid Demo</title>
    <style>
        :root {
            --space: 8px;
            --radius: 5px;
            
            --gray: #6c757d;
            --gray-bg: #f5f5f5;
            --blue: #007acc;
            --green: #28a745;
            --white: white;
            --dark: #333;
            
            --max-width: 1400px;
            --sidebar: 400px;
        }
        
        * { box-sizing: border-box; }
        
        body { 
            font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: var(--max-width);
            margin: 0 auto;
            padding: var(--space);
            background: var(--gray-bg);
        }
        
        .container { 
            background: var(--white);
            padding: calc(var(--space) * 1.5);
            border-radius: var(--radius);
        }
        
        .main-layout { 
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: calc(var(--space) * 1.5);
        }
        
        .api-column { 
            background: var(--gray-bg);
            padding: var(--space);
            border-radius: var(--radius);
            border-left: 4px solid var(--green);
        }
        
        h1 { 
            color: var(--dark);
            text-align: center;
            margin-bottom: calc(var(--space) * 1.5);
            grid-column: 1 / -1;
        }
        
        h2 { 
            color: var(--gray);
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: var(--space);
            margin-top: calc(var(--space) * 1.5);
        }
        
        .demo-section { 
            margin: var(--space) 0;
            padding: var(--space);
            background: var(--gray-bg);
            border-radius: var(--radius);
            border-left: 4px solid var(--blue);
        }
        
        .controls, .input-group { 
            display: flex;
            gap: var(--space);
            margin: 15px 0;
        }
        
        .controls { flex-wrap: wrap; }
        .input-group { align-items: center; }
        .feature-grid { display: grid; gap: var(--space); margin: var(--space) 0; }
        
        button { 
            background: var(--blue);
            color: var(--white);
            border: none;
            padding: var(--space) var(--space);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        button:hover { filter: brightness(0.9); }
        button:disabled { background: #ccc; cursor: not-allowed; }
        
        input[type="text"], input[type="number"], input[type="range"] { 
            padding: var(--space);
            border: 1px solid #ddd;
            border-radius: var(--radius);
        }
        
        input[type="number"] {
            width: 80px;
        }
        
        input[type="range"] {
            flex: 1;
        }
        
        .status, .code-example { 
            font-family: monospace;
            padding: var(--space);
            border-radius: var(--radius);
            margin: var(--space) 0;
        }
        
        .status { 
            background: var(--dark);
            color: #0f0;
            white-space: pre-wrap;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .code-example { 
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            overflow-x: auto;
            margin: var(--space) 0;
        }
        
        .highlight { color: #68d391; }
        .keyword { color: #fbb6ce; }
        .string { color: #fbd38d; }
        
        .api-section { margin: 15px 0; }
        .api-section h3 { 
            color: var(--green);
            margin: 0 0 var(--space) 0;
        }
        
        .api-method { 
            font-family: monospace;
            margin: 3px 0;
            color: var(--gray);
        }
        
        .api-method .method-name { color: var(--blue); font-weight: bold; }
        .api-method .return-type { color: #6f42c1; }
        .api-method .param { color: #e83e8c; }
        
        .api-description {
            margin: var(--space) 0;
        }
        
        .api-options {
            color: var(--gray);
        }
        
        .help-text {
            color: var(--gray);
            margin: var(--space) 0;
        }
        
        .code-comment {
            color: #68d391;
        }
        
        .grid-type { 
            display: flex;
            gap: var(--space);
            margin: var(--space) 0;
        }
        
        .grid-type label { 
            display: flex;
            align-items: center;
            gap: calc(var(--space) / 2);
        }
        
        canvas { 
            border: 1px solid #ddd; 
            border-radius: var(--radius);
            margin: var(--space) 0;
        }
        
        @media (max-width: 1200px) {
            .main-layout { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>U-Grid Demo</h1>

        
        <div class="main-layout">
            <div class="demo-column">
                <h2>Create a Grid</h2>
                <div class="demo-section">
                    <div class="grid-type">
                        <label><input type="radio" name="gridType" value="square" checked> Square Grid</label>
                        <label><input type="radio" name="gridType" value="hex"> Hex Grid</label>
                    </div>
                    <div class="controls">
                        <button onclick="createGrid()">Create 8x6 Grid</button>
                        <button onclick="fillGrid()">Fill Random</button>
                        <button onclick="clearGrid()">Clear Grid</button>
                    </div>
                    <canvas id="gridCanvas" width="400" height="300"></canvas>
                    <div class="status" id="gridDisplay">No grid created yet</div>
                </div>
            </div>

            <div class="api-column">
                <h2>Overview</h2>
                
                <div class="api-section">
                    <div class="api-method"><span class="method-name">UGrid.create</span>(<span class="param">cols, rows, options</span>) → <span class="return-type">Grid</span></div>
                    <div class="api-description">
                        Creates a new grid with specified dimensions and topology
                    </div>
                    <div class="api-method"><span class="method-name">grid.get</span>(<span class="param">x, y</span>) → <span class="return-type">Cell</span></div>
                    <div class="api-description">
                        Retrieves cell at coordinates
                    </div>
                </div>

                <div class="api-section">
                    <h3>Grid Methods</h3>
                    <div class="api-method"><span class="method-name">each</span>(<span class="param">callback</span>) → <span class="return-type">void</span></div>
                    <div class="api-description">Iterate over all cells</div>
                    
                    <div class="api-method"><span class="method-name">eachNeighborOf</span>(<span class="param">cell, callback</span>) → <span class="return-type">void</span></div>
                    <div class="api-description">Get adjacent cells</div>
                    
                    <div class="api-method"><span class="method-name">mapDistance</span>(<span class="param">cell1, cell2</span>) → <span class="return-type">number</span></div>
                    <div class="api-description">Calculate distance between cells</div>
                </div>

                <div class="api-section">
                    <h3>Examples</h3>
                    <pre class="code-example">
<span class="code-comment">// Create square grid</span>
<span class="keyword">let</span> grid = <span class="highlight">UGrid.create</span>(<span class="string">8</span>, <span class="string">6</span>, {
  type: <span class="highlight">UGrid.square</span>,
  cellSize: <span class="string">30</span>
});

<span class="code-comment">// Access cells</span>
<span class="keyword">let</span> cell = grid.<span class="highlight">get</span>(<span class="string">3</span>, <span class="string">2</span>);
cell.value = <span class="string">42</span>;
</pre>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="demo-column">
                <h2>Cell Access</h2>
                <div class="demo-section">
                    <div class="input-group">
                        <label>X:</label>
                        <input type="number" id="getX" min="0" max="7" value="3">
                        <label>Y:</label>
                        <input type="number" id="getY" min="0" max="5" value="2">
                    </div>
                    <div class="controls">
                        <button onclick="getValue()">Get Value</button>
                        <button onclick="setValue()">Set Random</button>
                        <button onclick="showNeighbors()">Show Neighbors</button>
                    </div>
                    <div class="status" id="accessResult">No operations performed</div>
                </div>

                <div class="demo-section">
                    <h3>Path Finding</h3>
                    <div class="input-group">
                        <label>Start X:</label>
                        <input type="number" id="pathStartX" min="0" max="7" value="0">
                        <label>Y:</label>
                        <input type="number" id="pathStartY" min="0" max="5" value="0">
                        <label>End X:</label>
                        <input type="number" id="pathEndX" min="0" max="7" value="7">
                        <label>Y:</label>
                        <input type="number" id="pathEndY" min="0" max="5" value="5">
                    </div>
                    <div class="controls">
                        <button onclick="findPath()">Find Path (Terrain Cost)</button>
                        <button onclick="findPathIgnoreTerrain()">Find Path (Ignore Terrain)</button>
                        <button onclick="addObstacles()">Add Obstacles</button>
                        <button onclick="clearPath()">Clear Path</button>
                    </div>
                    <div class="help-text">Higher cell values = higher terrain cost for pathfinding</div>
                </div>
            </div>

            <div class="api-column">
                <h2>Pathfinding</h2>
                
                <div class="api-section">
                    <h3>PathAStar Integration</h3>
                    <div class="api-description">
                        UGrid and PathAStar are designed to work together. UGrid provides neighbor traversal and distance calculation, while PathAStar handles the A* algorithm with cost optimization.
                    </div>
                </div>

                <div class="api-section">
                    <h3>Terrain-Based Pathfinding</h3>
                    <pre class="code-example">
<span class="code-comment">// Setup grid cells with unique IDs</span>
grid.<span class="highlight">each</span>(<span class="keyword">function</span>(cell) {
  cell.gridId = <span class="string">`${cell.x}_${cell.y}`</span>;
});

<span class="code-comment">// Configure PathAStar for grid integration</span>
<span class="highlight">PathAStar.config.nodeIdField</span> = <span class="string">'gridId'</span>;

<span class="code-comment">// Pathfinding with terrain costs</span>
<span class="keyword">let</span> result = <span class="highlight">PathAStar.find</span>(
  startCell, endCell,
  <span class="keyword">function</span>(node, callback) {
    grid.<span class="highlight">eachNeighborOf</span>(node, <span class="keyword">function</span>(neighbor) {
      <span class="keyword">if</span> (!neighbor.obstacle) callback(neighbor);
    });
  },
  <span class="keyword">function</span>(from, to) {
    <span class="keyword">let</span> distance = grid.<span class="highlight">mapDistance</span>(from, to);
    <span class="keyword">let</span> terrainCost = to.value || <span class="string">1</span>;
    <span class="keyword">return</span> distance * terrainCost;
  }
);
</pre>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="demo-column">
                <h2>Iterating over cells</h2>
                <div class="demo-section">
                    <canvas id="analysisCanvas" width="400" height="250"></canvas>
                    <div class="controls">
                        <button onclick="analyzeGrid()">Analyze Grid</button>
                        <button onclick="generateMaze()">Generate Maze</button>
                        <button onclick="generateTerrain()">Generate Terrain</button>
                    </div>
                    <div class="status" id="analysisResult">No analysis performed</div>
                </div>
            </div>

            <div class="api-column">
                
                <div class="api-section">
                    <h3>Square vs Hexagonal</h3>
                    <div class="api-description">
                        Square grids provide 4 or 8-directional movement, while hexagonal grids offer 6-directional movement with uniform distances.
                    </div>
                </div>

                <div class="api-section">
                    <pre class="code-example">
<span class="code-comment">// Square grid with 8 directions</span>
<span class="keyword">let</span> square = <span class="highlight">UGrid.create</span>(<span class="string">10</span>, <span class="string">10</span>, {
  type: <span class="highlight">UGrid.square</span>,
  diagonal: <span class="keyword">true</span>
});

<span class="code-comment">// Hexagonal grid</span>
<span class="keyword">let</span> hex = <span class="highlight">UGrid.create</span>(<span class="string">10</span>, <span class="string">10</span>, {
  type: <span class="highlight">UGrid.pointyTop</span>
});

<span class="code-comment">// Custom cell properties</span>
cell.terrain = <span class="string">'forest'</span>;
cell.movement = <span class="string">2</span>;
</pre>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="demo-column">
                <h2>Field of View & Visibility</h2>
                
                <div class="demo-section">
                    <h3>Basic FOV</h3>
                    <canvas id="fovCanvas" width="400" height="300"></canvas>
                    <div class="input-group">
                        <label>Center X:</label>
                        <input type="number" id="fovCenterX" min="0" max="7" value="4">
                        <label>Y:</label>
                        <input type="number" id="fovCenterY" min="0" max="5" value="3">
                        <label>Radius:</label>
                        <input type="number" id="fovRadius" min="1" max="8" value="3">
                    </div>
                    <div class="controls">
                        <button onclick="calculateBasicFOV()">Calculate Basic FOV</button>
                        <button onclick="calculateLineFOV()">Line of Sight FOV</button>
                        <button onclick="calculateShadowFOV()">Shadow Casting FOV</button>
                        <button onclick="clearFOV()">Clear FOV</button>
                    </div>
                    <div class="help-text">Basic FOV uses simple distance calculation</div>
                </div>

                <div class="demo-section">
                    <h3>Advanced Visibility</h3>
                    <canvas id="visibilityCanvas" width="400" height="300"></canvas>
                    <div class="controls">
                        <button onclick="addWalls()">Add Walls</button>
                        <button onclick="calculateVisibilityWithWalls()">Calculate with Walls</button>
                        <button onclick="animateVisibility()">Animate Visibility</button>
                        <button onclick="clearWalls()">Clear Walls</button>
                    </div>
                    <div class="status" id="fovResult">No FOV calculated</div>
                </div>
            </div>

            <div class="api-column">

                <div class="api-section">
                    <h3>FOV Examples</h3>
                    <pre class="code-example">
<span class="code-comment">// Basic circular FOV</span>
<span class="keyword">function</span> <span class="highlight">calculateBasicFOV</span>(center, radius) {
  <span class="keyword">let</span> visible = [];
  grid.<span class="highlight">each</span>(<span class="keyword">function</span>(cell) {
    <span class="keyword">let</span> distance = grid.<span class="highlight">mapDistance</span>(center, cell);
    <span class="keyword">if</span> (distance <= radius * grid.cellSize) {
      cell.fov = <span class="keyword">true</span>;
      visible.push(cell);
    }
  });
  <span class="keyword">return</span> visible;
}

<span class="code-comment">// Line of sight FOV</span>
<span class="keyword">function</span> <span class="highlight">hasLineOfSight</span>(from, to) {
  <span class="keyword">let</span> path = <span class="highlight">bresenhamLine</span>(from, to);
  <span class="keyword">for</span> (<span class="keyword">let</span> cell <span class="keyword">of</span> path) {
    <span class="keyword">if</span> (cell.wall) <span class="keyword">return</span> <span class="keyword">false</span>;
  }
  <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="code-comment">// Shadow casting algorithm</span>
<span class="keyword">function</span> <span class="highlight">castShadows</span>(center, radius) {
  <span class="keyword">for</span> (<span class="keyword">let</span> angle = <span class="string">0</span>; angle < <span class="string">360</span>; angle += <span class="string">5</span>) {
    <span class="keyword">let</span> ray = <span class="highlight">castRay</span>(center, angle, radius);
    <span class="highlight">markVisibleCells</span>(ray);
  }
}
</pre>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="demo-column">
                <h2>More Examples</h2>
                
                <div class="demo-section">
                    <h3>Movement</h3>
                    <canvas id="movementCanvas" width="200" height="200"></canvas>
                    <div class="controls">
                        <button onclick="startMovement()">Start Movement</button>
                        <button onclick="stopMovement()">Stop</button>
                    </div>
                </div>

                <div class="demo-section">
                    <h3>Flood Fill</h3>
                    <canvas id="floodCanvas" width="200" height="150"></canvas>
                    <div class="controls">
                        <button onclick="performFloodFill()">Flood Fill</button>
                        <button onclick="resetFlood()">Reset</button>
                    </div>
                </div>
            </div>

            <div class="api-column">

                <div class="api-section">
                    <h3>Game Examples</h3>
                    <pre class="code-example">
<span class="code-comment">// Game board setup</span>
<span class="keyword">let</span> board = <span class="highlight">UGrid.create</span>(<span class="string">8</span>, <span class="string">8</span>);
board.<span class="highlight">each</span>(cell => {
  cell.piece = <span class="keyword">null</span>;
  cell.color = (cell.x + cell.y) % <span class="string">2</span>;
});

<span class="code-comment">// Movement validation</span>
<span class="keyword">function</span> <span class="highlight">canMoveTo</span>(from, to) {
  <span class="keyword">let</span> distance = grid.<span class="highlight">mapDistance</span>(from, to);
  <span class="keyword">return</span> distance <= cellSize && to.piece === <span class="keyword">null</span>;
}

<span class="code-comment">// Area of effect</span>
<span class="keyword">let</span> affected = [];
grid.<span class="highlight">eachInDistanceOf</span>(center, <span class="string">3</span>, <span class="keyword">function</span>(cell) {
  affected.push(cell);
  cell.damaged = <span class="keyword">true</span>;
});
</pre>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="demo-column">
                <h2>Grid Information</h2>
                <div class="demo-section">
                    <div class="controls">
                        <button onclick="showInfo()">Show Grid Info</button>
                        <button onclick="exportGrid()">Export Grid</button>
                        <button onclick="importGrid()">Import Sample</button>
                    </div>
                    <div class="status" id="infoResult">No info available</div>
                </div>

                <div class="demo-section">
                    <h3>Performance Test</h3>
                    <div class="input-group">
                        <label>Operations:</label>
                        <input type="number" id="perfOps" value="10000" min="1000" max="1000000" step="1000">
                        <button onclick="performanceTest()">Test</button>
                    </div>
                    <div class="status" id="perfResult">No test performed</div>
                </div>
            </div>

            <div class="api-column">
                <h2>Advanced Features</h2>
                
                <div class="api-section">
                    <h3>Grid Serialization</h3>
                    <div class="api-description">
                        Export and import grid data for save states, level loading, and data persistence.
                    </div>
                </div>

                <div class="api-section">
                    <h3>Serialization Examples</h3>
                    <pre class="code-example">
<span class="code-comment">// Export grid state</span>
<span class="keyword">let</span> json = <span class="highlight">JSON.stringify</span>({
  width: grid.colCount,
  height: grid.rowCount,
  cells: grid.cells,
});
</pre>
                </div>

            </div>
        </div>
    </div>

    <script src="u-helper.js"></script>
    <script src="u-grid.js"></script>
    <script src="u-pathastar.js"></script>
    <script>
        let grid = null;
        let selectedCells = [];
        let movementInterval = null;
        let playerPosition = null;

        PathAStar.config.nodeIdField = 'gridId';

        function getElement(id) {
            return document.getElementById(id);
        }

        function getIntValue(id) {
            return parseInt(getElement(id).value);
        }

        function getCanvasContext(canvasId) {
            let canvas = getElement(canvasId);
            let ctx = canvas.getContext('2d');
            return { canvas, ctx };
        }

        function clearCanvas(canvasId) {
            let { canvas, ctx } = getCanvasContext(canvasId);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return { canvas, ctx };
        }

        function log(message, outputId = 'accessResult') {
            let output = getElement(outputId);
            let timestamp = new Date().toLocaleTimeString();
            output.textContent += `[${timestamp}] ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }

        function clearOutput(outputId) {
            getElement(outputId).textContent = '';
        }

        function ensureGrid() {
            if (!grid) {
                createGrid();
            }
            return grid;
        }

        function clearCellProperties(propertiesToClear = ['highlighted', 'path']) {
            if (!grid) return;
            
            grid.each(function(cell) {
                propertiesToClear.forEach(prop => {
                    delete cell[prop];
                });
            });
        }

        function createGrid() {
            let gridType = document.querySelector('input[name="gridType"]:checked').value;
            let type = gridType === 'hex' ? UGrid.pointyTop : UGrid.square;
            let cellSize = gridType === 'hex' ? 25 : 30;
            
            grid = UGrid.create(8, 6, { 
                type: type, 
                cellSize: cellSize,
                mapOffsetX: 50,
                mapOffsetY: 50
            });
            
            grid.each(function(cell) {
                cell.gridId = `${cell.x}_${cell.y}`;
            });
            
            drawGrid();
            clearOutput('accessResult');
            log(`Grid created: 8x6 ${gridType} grid`, 'accessResult');
        }

        function fillGrid() {
            ensureGrid();
            
            grid.each(function(cell) {
                cell.value = Math.floor(Math.random() * 10);
            });
            
            drawGrid();
            clearOutput('accessResult');
            log('Grid filled with random values (0-9)', 'accessResult');
        }

        function clearGrid() {
            ensureGrid();
            
            grid.each(function(cell) {
                cell.value = 0;
            });
            
            clearCellProperties(['highlighted', 'path', 'fov', 'obstacle']);
            drawGrid();
            clearOutput('accessResult');
            log('Grid cleared to zeros', 'accessResult');
        }

        function getValue() {
            ensureGrid();
            
            let x = getIntValue('getX');
            let y = getIntValue('getY');
            let cell = grid.get(x, y);
            
            clearOutput('accessResult');
            if (cell) {
                let value = cell.value || 0;
                log(`Value at (${x}, ${y}): ${value}`, 'accessResult');
                
                highlightCell(cell, '#ff0000');
                drawGrid();
            } else {
                log(`Invalid coordinates: (${x}, ${y})`, 'accessResult');
            }
        }

        function setValue() {
            ensureGrid();
            
            let x = getIntValue('getX');
            let y = getIntValue('getY');
            let newValue = Math.floor(Math.random() * 10);
            let cell = grid.get(x, y);
            
            clearOutput('accessResult');
            if (cell) {
                cell.value = newValue;
                log(`Set (${x}, ${y}) to: ${newValue}`, 'accessResult');
                
                highlightCell(cell, '#00ff00');
                drawGrid();
            } else {
                log(`Invalid coordinates: (${x}, ${y})`, 'accessResult');
            }
        }

        function showNeighbors() {
            ensureGrid();
            
            let x = getIntValue('getX');
            let y = getIntValue('getY');
            let cell = grid.get(x, y);
            
            clearOutput('accessResult');
            if (cell) {
                let neighbors = [];
                grid.eachNeighborOf(cell, function(neighbor) {
                    neighbors.push(neighbor);
                });
                
                log(`Cell (${x}, ${y}) has ${neighbors.length} neighbors:`, 'accessResult');
                
                neighbors.forEach((neighbor, index) => {
                    log(`${index + 1}: (${neighbor.x}, ${neighbor.y}) = ${neighbor.value || 0}`, 'accessResult');
                    neighbor.highlighted = '#ffaa00';
                });
                
                cell.highlighted = '#ff0000';
                drawGrid();
            } else {
                log(`Invalid coordinates: (${x}, ${y})`, 'accessResult');
            }
        }

        function addObstacles() {
            ensureGrid();
            
            let availableCells = [];
            grid.each(function(cell) {
                if (!cell.obstacle) {
                    availableCells.push(cell);
                }
            });
            
            let obstacleCount = 8;
            for (let i = 0; i < obstacleCount && availableCells.length > 0; i++) {
                let cell = selectRandom(availableCells, true);
                cell.obstacle = true;
                cell.value = 99;
            }
            
            drawGrid();
            clearOutput('accessResult');
            log(`Added ${obstacleCount} impassable obstacles`, 'accessResult');
        }

        function findPathWithOptions(useTerrainCost = true) {
            ensureGrid();
            
            let startX = getIntValue('pathStartX');
            let startY = getIntValue('pathStartY');
            let endX = getIntValue('pathEndX');
            let endY = getIntValue('pathEndY');
            
            let startCell = grid.get(startX, startY);
            let endCell = grid.get(endX, endY);
            
            if (!startCell || !endCell) {
                clearOutput('accessResult');
                log('Invalid coordinates', 'accessResult');
                return;
            }
            
            let costFunction = useTerrainCost 
                ? function(fromNode, toNode) {
                    let baseMovementCost = grid.mapDistance(fromNode, toNode);
                    let terrainCost = (toNode.value || 1);
                    return baseMovementCost * terrainCost;
                  }
                : function(fromNode, toNode) {
                    return grid.mapDistance(fromNode, toNode);
                  };
            
            let result = PathAStar.find(
                startCell,
                endCell,
                function(currentNode, neighborCallback) {
                    grid.eachNeighborOf(currentNode, function(neighbor) {
                        if (!neighbor.obstacle) {
                            neighborCallback(neighbor);
                        }
                    });
                },
                costFunction,
                function(fromNode, toNode) {
                    return grid.mapDistance(fromNode, toNode);
                }
            );
            
            let pathType = useTerrainCost ? 'with terrain costs' : 'ignoring terrain';
            displayPathResult(result, startX, startY, endX, endY, pathType);
        }

        function findPath() {
            findPathWithOptions(true);
        }

        function findPathIgnoreTerrain() {
            findPathWithOptions(false);
        }

        function displayPathResult(result, startX, startY, endX, endY, pathType) {
            clearOutput('accessResult');
            if (result.result === 'path') {
                log(`Path ${pathType} from (${startX},${startY}) to (${endX},${endY}):`, 'accessResult');
                log(`Steps: ${result.path.length}`, 'accessResult');
                log(`Total cost: ${result.debug.totalCost.toFixed(2)}`, 'accessResult');
                log(`Search time: ${result.debug.time.toFixed(4)}s`, 'accessResult');
                log(`Nodes considered: ${result.debug.nodesConsidered}`, 'accessResult');
                
                clearCellProperties(['path', 'highlighted']);
                
                result.path.forEach(cell => {
                    cell.path = true;
                });
                
                result.path[0].highlighted = '#00ff00';
                result.path[result.path.length - 1].highlighted = '#ff0000';
                drawGrid();
            } else {
                log(`No path ${pathType} from (${startX},${startY}) to (${endX},${endY})`, 'accessResult');
                log(`Search time: ${result.debug.time.toFixed(4)}s`, 'accessResult');
                log(`Nodes considered: ${result.debug.nodesConsidered}`, 'accessResult');
            }
        }

        function clearPath() {
            if (!grid) return;
            
            clearCellProperties(['path', 'highlighted']);
            drawGrid();
            clearOutput('accessResult');
            log('Path cleared', 'accessResult');
        }

        function analyzeGrid() {
            ensureGrid();
            
            let { canvas, ctx } = clearCanvas('analysisCanvas');
            
            let sum = 0;
            let min = Infinity;
            let max = -Infinity;
            let count = 0;
            
            grid.each(function(cell) {
                let value = cell.value || 0;
                sum += value;
                min = Math.min(min, value);
                max = Math.max(max, value);
                count++;
            });
            
            let mean = sum / count;
            let range = max - min;
            
            let histogram = new Array(10).fill(0);
            grid.each(function(cell) {
                let value = cell.value || 0;
                histogram[value]++;
            });
            
            let maxCount = Math.max(...histogram);
            let barWidth = canvas.width / histogram.length;
            let margin = 30;
            let plotHeight = canvas.height - 2 * margin;
            
            ctx.fillStyle = '#4ecdc4';
            for (let i = 0; i < histogram.length; i++) {
                let barHeight = (histogram[i] / maxCount) * plotHeight;
                let x = i * barWidth;
                let y = canvas.height - margin - barHeight;
                
                ctx.fillRect(x, y, barWidth - 1, barHeight);
                
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(i.toString(), x + barWidth / 2, canvas.height - 5);
                ctx.fillStyle = '#4ecdc4';
            }
            
            clearOutput('analysisResult');
            log(`Grid Analysis:`, 'analysisResult');
            log(`Total cells: ${count}`, 'analysisResult');
            log(`Mean value: ${mean.toFixed(2)}`, 'analysisResult');
            log(`Range: ${min} - ${max}`, 'analysisResult');
            log(`Sum: ${sum}`, 'analysisResult');
        }

        function generateMaze() {
            ensureGrid();
            
            grid.each(function(cell) {
                cell.value = 1;
            });
            
            let visited = new Set();
            let stack = [];
            let startCell = grid.get(0, 0);
            
            startCell.value = 0;
            visited.add(startCell);
            stack.push(startCell);
            
            while (stack.length > 0) {
                let current = stack[stack.length - 1];
                let neighbors = [];
                
                grid.eachNeighborOf(current, function(neighbor) {
                    if (!visited.has(neighbor)) {
                        neighbors.push(neighbor);
                    }
                });
                
                if (neighbors.length > 0) {
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    next.value = 0;
                    visited.add(next);
                    stack.push(next);
                } else {
                    stack.pop();
                }
            }
            
            drawGrid();
            clearOutput('analysisResult');
            log('Maze generated using recursive backtracking', 'analysisResult');
        }

        function generateTerrain() {
            ensureGrid();
            
            grid.each(function(cell) {
                let noise1 = Math.sin(cell.x * 0.3) * Math.cos(cell.y * 0.2);
                let noise2 = Math.sin(cell.x * 0.1 + cell.y * 0.1) * 0.5;
                let height = ((noise1 + noise2) * 0.5 + 1) * 4.5;
                cell.value = Math.floor(height);
            });
            
            drawGrid();
            clearOutput('analysisResult');
            log('Terrain generated using sine wave noise', 'analysisResult');
        }

        function startMovement() {
            ensureGrid();
            
            if (movementInterval) return;
            
            playerPosition = grid.get(0, 0);
            
            movementInterval = setInterval(() => {
                let neighbors = [];
                grid.eachNeighborOf(playerPosition, function(neighbor) {
                    neighbors.push(neighbor);
                });
                
                if (neighbors.length > 0) {
                    playerPosition = selectRandom(neighbors);
                    drawMovementDemo();
                }
            }, 500);
        }

        function stopMovement() {
            if (movementInterval) {
                clearInterval(movementInterval);
                movementInterval = null;
            }
        }

        function drawMovementDemo() {
            let { canvas, ctx } = clearCanvas('movementCanvas');
            
            if (!grid || !playerPosition) return;
            
            let scale = Math.min(canvas.width / grid.colCount, canvas.height / grid.rowCount);
            
            grid.each(function(cell) {
                let x = cell.x * scale + scale / 2;
                let y = cell.y * scale + scale / 2;
                
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(cell.x * scale, cell.y * scale, scale, scale);
                
                ctx.strokeStyle = '#ddd';
                ctx.strokeRect(cell.x * scale, cell.y * scale, scale, scale);
            });
            
            let playerX = playerPosition.x * scale + scale / 2;
            let playerY = playerPosition.y * scale + scale / 2;
            
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(playerX, playerY, scale / 3, 0, 2 * Math.PI);
            ctx.fill();
        }

        function calculateFOV() {
            calculateBasicFOV();
        }

        function calculateBasicFOV() {
            ensureGrid();
            
            let centerX = getIntValue('fovCenterX');
            let centerY = getIntValue('fovCenterY');
            let radius = getIntValue('fovRadius');
            let center = grid.get(centerX, centerY);
            
            if (!center) {
                clearOutput('fovResult');
                log('Invalid center coordinates', 'fovResult');
                return;
            }
            
            clearCellProperties(['fov', 'visible', 'center']);
            
            let visible = [];
            grid.each(function(cell) {
                let distance = dist(center.x, center.y, cell.x, cell.y);
                if (distance <= radius) {
                    cell.fov = true;
                    cell.visible = true;
                    visible.push(cell);
                }
            });
            
            center.center = true;
            drawFOVDemo();
            drawVisibilityDemo();
            clearOutput('fovResult');
            log(`Basic FOV: ${visible.length} cells visible`, 'fovResult');
            log(`Center: (${centerX}, ${centerY}), Radius: ${radius}`, 'fovResult');
            log(`Algorithm: Simple distance calculation`, 'fovResult');
        }

        function calculateLineFOV() {
            ensureGrid();
            
            let centerX = getIntValue('fovCenterX');
            let centerY = getIntValue('fovCenterY');
            let radius = getIntValue('fovRadius');
            let center = grid.get(centerX, centerY);
            
            if (!center) {
                clearOutput('fovResult');
                log('Invalid center coordinates', 'fovResult');
                return;
            }
            
            clearCellProperties(['fov', 'visible', 'center']);
            
            let visible = [];
            grid.each(function(cell) {
                let distance = dist(center.x, center.y, cell.x, cell.y);
                if (distance <= radius) {
                    if (hasLineOfSight(center, cell)) {
                        cell.fov = true;
                        cell.visible = true;
                        visible.push(cell);
                    }
                }
            });
            
            center.center = true;
            drawFOVDemo();
            drawVisibilityDemo();
            clearOutput('fovResult');
            log(`Line of Sight FOV: ${visible.length} cells visible`, 'fovResult');
            log(`Algorithm: Bresenham line algorithm with wall blocking`, 'fovResult');
            log(`Walls (█) block line of sight`, 'fovResult');
        }

        function calculateShadowFOV() {
            ensureGrid();
            
            let centerX = getIntValue('fovCenterX');
            let centerY = getIntValue('fovCenterY');
            let radius = getIntValue('fovRadius');
            let center = grid.get(centerX, centerY);
            
            if (!center) {
                clearOutput('fovResult');
                log('Invalid center coordinates', 'fovResult');
                return;
            }
            
            clearCellProperties(['fov', 'visible', 'center', 'shadow']);
            
            let visible = castShadowFOV(center, radius);
            
            center.center = true;
            drawFOVDemo();
            drawVisibilityDemo();
            clearOutput('fovResult');
            log(`Shadow Casting FOV: ${visible.length} cells visible`, 'fovResult');
            log(`Algorithm: Ray casting with shadow generation`, 'fovResult');
            log(`360° ray casting every 2 degrees`, 'fovResult');
        }

        function hasLineOfSight(from, to) {
            let points = bresenham_line(from.x, from.y, to.x, to.y);
            for (let i = 1; i < points.length - 1; i++) {
                let [x, y] = points[i];
                let cell = grid.get(x, y);
                if (cell && cell.wall) {
                    return false;
                }
            }
            return true;
        }

        function castShadowFOV(center, radius) {
            let visible = [];
            
            for (let angle = 0; angle < 360; angle += 2) {
                let ray = castRay(center, angle, radius);
                ray.forEach(cell => {
                    if (cell && !cell.fov) {
                        cell.fov = true;
                        cell.visible = true;
                        visible.push(cell);
                    }
                });
            }
            
            return visible;
        }

        function castRay(center, angle, maxDistance) {
            let ray = [];
            let radians = (angle * Math.PI) / 180;
            let dx = Math.cos(radians);
            let dy = Math.sin(radians);
            
            for (let step = 0; step <= maxDistance; step += 0.25) {
                let x = Math.round(center.x + dx * step);
                let y = Math.round(center.y + dy * step);
                let cell = grid.get(x, y);
                
                if (!cell) break;
                
                ray.push(cell);
                
                if (cell.wall) {
                    break;
                }
            }
            
            return ray;
        }

        function addWalls() {
            ensureGrid();
            
            let availableCells = [];
            grid.each(function(cell) {
                if (!cell.wall) {
                    availableCells.push(cell);
                }
            });
            
            let wallCount = 12;
            for (let i = 0; i < wallCount && availableCells.length > 0; i++) {
                let cell = selectRandom(availableCells, true);
                cell.wall = true;
                cell.value = 8;
            }
            
            drawFOVDemo();
            drawVisibilityDemo();
            clearOutput('fovResult');
            log(`Added ${wallCount} walls to block visibility`, 'fovResult');
        }

        function clearWalls() {
            if (!grid) return;
            
            grid.each(function(cell) {
                if (cell.wall) {
                    delete cell.wall;
                    cell.value = 0;
                }
            });
            
            drawFOVDemo();
            drawVisibilityDemo();
            clearOutput('fovResult');
            log('All walls cleared', 'fovResult');
        }

        function calculateVisibilityWithWalls() {
            calculateLineFOV();
            drawVisibilityDemo();
        }

        function animateVisibility() {
            ensureGrid();
            
            let angle = 0;
            let radius = getIntValue('fovRadius');
            let centerX = getIntValue('fovCenterX');
            let centerY = getIntValue('fovCenterY');
            let center = grid.get(centerX, centerY);
            
            if (!center) return;
            
            clearOutput('fovResult');
            log('Starting visibility animation...', 'fovResult');
            
            let interval = setInterval(() => {
                clearCellProperties(['fov', 'visible', 'center']);
                
                let visible = [];
                for (let a = angle; a < angle + 60; a += 2) {
                    let ray = castRay(center, a, radius);
                    ray.forEach(cell => {
                        if (cell && !cell.fov) {
                            cell.fov = true;
                            cell.visible = true;
                            visible.push(cell);
                        }
                    });
                }
                
                center.center = true;
                drawVisibilityDemo();
                
                angle += 10;
                if (angle >= 360) {
                    clearInterval(interval);
                    clearOutput('fovResult');
                    log('Animation complete - full 360° scan', 'fovResult');
                }
            }, 100);
        }

        function clearFOV() {
            if (!grid) return;
            
            clearCellProperties(['fov', 'visible', 'center', 'shadow']);
            drawFOVDemo();
            drawVisibilityDemo();
            clearOutput('fovResult');
            log('FOV cleared', 'fovResult');
        }

        function drawFOVDemo() {
            let { canvas, ctx } = clearCanvas('fovCanvas');
            
            if (!grid) return;
            
            let scale = Math.min(canvas.width / grid.colCount, canvas.height / grid.rowCount);
            
            grid.each(function(cell) {
                let x = cell.x * scale;
                let y = cell.y * scale;
                
                let fillColor = '#333';
                if (cell.center) {
                    fillColor = '#ff4444';
                } else if (cell.wall) {
                    fillColor = '#000000';
                } else if (cell.fov || cell.visible) {
                    fillColor = '#ffff99';
                } else {
                    let value = cell.value || 0;
                    let intensity = clamp01(value / 10);
                    let r = Math.round((1 - intensity) * 255);
                    let g = Math.round((1 - intensity * 0.8) * 255);
                    let b = Math.round((1 - intensity * 0.6) * 255);
                    fillColor = `rgb(${r}, ${g}, ${b})`;
                }
                
                ctx.fillStyle = fillColor;
                ctx.fillRect(x, y, scale, scale);
                
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(x, y, scale, scale);
                
                if (cell.wall) {
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.max(8, scale * 0.4)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('█', x + scale/2, y + scale/2);
                } else if (cell.center) {
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.max(8, scale * 0.5)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('👁', x + scale/2, y + scale/2);
                }
            });
        }

        function drawVisibilityDemo() {
            let { canvas, ctx } = clearCanvas('visibilityCanvas');
            
            if (!grid) return;
            
            let scale = Math.min(canvas.width / grid.colCount, canvas.height / grid.rowCount);
            
            grid.each(function(cell) {
                let x = cell.x * scale;
                let y = cell.y * scale;
                
                let fillColor = '#333';
                if (cell.center) {
                    fillColor = '#ff4444';
                } else if (cell.wall) {
                    fillColor = '#000000';
                } else if (cell.fov || cell.visible) {
                    fillColor = '#ffff99';
                } else {
                    fillColor = '#666';
                }
                
                ctx.fillStyle = fillColor;
                ctx.fillRect(x, y, scale, scale);
                
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(x, y, scale, scale);
                
                if (cell.wall) {
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.max(8, scale * 0.4)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('█', x + scale/2, y + scale/2);
                } else if (cell.center) {
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.max(8, scale * 0.5)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('👁', x + scale/2, y + scale/2);
                }
            });
        }

        function performFloodFill() {
            ensureGrid();
            
            let startCell = grid.get(2, 2);
            let targetValue = startCell.value || 0;
            let newValue = 9;
            
            let stack = [startCell];
            let filled = new Set();
            
            while (stack.length > 0) {
                let cell = stack.pop();
                if (filled.has(cell) || (cell.value || 0) !== targetValue) continue;
                
                cell.value = newValue;
                filled.add(cell);
                
                grid.eachNeighborOf(cell, function(neighbor) {
                    if (!filled.has(neighbor) && (neighbor.value || 0) === targetValue) {
                        stack.push(neighbor);
                    }
                });
            }
            
            drawFloodDemo();
            clearOutput('accessResult');
            log(`Flood fill completed: ${filled.size} cells filled`, 'accessResult');
        }

        function resetFlood() {
            ensureGrid();
            
            grid.each(function(cell) {
                cell.value = Math.floor(Math.random() * 3);
            });
            
            drawFloodDemo();
        }

        function drawFloodDemo() {
            let { canvas, ctx } = clearCanvas('floodCanvas');
            
            if (!grid) return;
            
            let scale = Math.min(canvas.width / grid.colCount, canvas.height / grid.rowCount);
            
            grid.each(function(cell) {
                let x = cell.x * scale;
                let y = cell.y * scale;
                let value = cell.value || 0;
                
                let colors = ['#ffffff', '#cccccc', '#999999', '#666666', '#333333', 
                              '#ff9999', '#99ff99', '#9999ff', '#ffff99', '#ff99ff'];
                
                ctx.fillStyle = colors[value] || '#000000';
                ctx.fillRect(x, y, scale, scale);
                
                ctx.strokeStyle = '#444';
                ctx.strokeRect(x, y, scale, scale);
            });
        }

        function showInfo() {
            if (!grid) {
                clearOutput('infoResult');
                log('No grid created', 'infoResult');
                return;
            }
            
            clearOutput('infoResult');
            log(`Grid Information:`, 'infoResult');
            log(`Width: ${grid.colCount}`, 'infoResult');
            log(`Height: ${grid.rowCount}`, 'infoResult');
            log(`Total cells: ${grid.colCount * grid.rowCount}`, 'infoResult');
            log(`Topology: ${grid.topology}`, 'infoResult');
            log(`Cell size: ${grid.cellSize}`, 'infoResult');
            
            if (grid.mapOffsetX !== undefined) {
                log(`Offset: (${grid.mapOffsetX}, ${grid.mapOffsetY})`, 'infoResult');
            }
        }

        function exportGrid() {
            if (!grid) {
                clearOutput('infoResult');
                log('No grid to export', 'infoResult');
                return;
            }
            
            let data = {
                colCount: grid.colCount,
                rowCount: grid.rowCount,
                topology: grid.topology,
                cellSize: grid.cellSize,
                cells: grid.cells
            };
            
            let json = JSON.stringify(data, null, 2);
            
            clearOutput('infoResult');
            log('Grid exported to JSON:', 'infoResult');
            log(`${json.length} characters exported`, 'infoResult');
            log(json.substring(0, 300) + '...', 'infoResult');
        }

        function importGrid() {
            let sampleData = {
                colCount: 8,
                rowCount: 6,
                topology: 'square',
                cellSize: 30,
                cells: [
                    [{x: 0, y: 0, value: 0}, {x: 1, y: 0, value: 5}],
                    [{x: 0, y: 1, value: 7}, {x: 1, y: 1, value: 3}]
                ]
            };
            
            createGrid();
            
            if (sampleData.cells && sampleData.cells.length > 0) {
                grid.each(function(cell) {
                    cell.value = Math.floor(Math.random() * 5);
                });
                
                let testCells = [
                    {x: 1, y: 1, value: 8},
                    {x: 3, y: 2, value: 9},
                    {x: 5, y: 3, value: 7},
                    {x: 2, y: 4, value: 6}
                ];
                
                testCells.forEach(data => {
                    let cell = grid.get(data.x, data.y);
                    if (cell) cell.value = data.value;
                });
            }
            
            drawGrid();
            clearOutput('infoResult');
            log('Sample grid imported with test data', 'infoResult');
        }

        function performanceTest() {
            let operations = getIntValue('perfOps');
            
            ensureGrid();
            
            let startTime = performance.now();
            
            for (let i = 0; i < operations; i++) {
                let x = Math.floor(Math.random() * grid.colCount);
                let y = Math.floor(Math.random() * grid.rowCount);
                let cell = grid.get(x, y);
                if (cell) {
                    cell.value = Math.random();
                    grid.eachNeighborOf(cell, function(neighbor) {
                        neighbor.temp = true;
                    });
                }
            }
            
            let endTime = performance.now();
            let duration = endTime - startTime;
            let opsPerSecond = Math.floor(operations / (duration / 1000));
            
            clearOutput('perfResult');
            log(`Performance Test Results:`, 'perfResult');
            log(`Operations: ${operations}`, 'perfResult');
            log(`Duration: ${duration.toFixed(2)}ms`, 'perfResult');
            log(`Rate: ${opsPerSecond} ops/second`, 'perfResult');
        }

        function drawGrid() {
            if (!grid) return;
            
            let { canvas, ctx } = getCanvasContext('gridCanvas');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            grid.each(function(cell) {
                drawCell(cell, ctx);
            });
            
            displayGridText();
        }

        function drawCell(cell, ctx) {
            let pos = cell.pos;
            let value = cell.value || 0;
            
            let fillColor = '#ffffff';
            if (cell.obstacle) {
                fillColor = '#000000';
            } else if (cell.highlighted) {
                fillColor = cell.highlighted;
            } else if (cell.path) {
                fillColor = '#99ccff';
            } else if (cell.fov) {
                fillColor = '#ffff99';
            } else {
                let intensity = clamp01(value / 10);
                let r = Math.round((1 - intensity) * 255);
                let g = Math.round((1 - intensity * 0.8) * 255);
                let b = Math.round((1 - intensity * 0.6) * 255);
                fillColor = `rgb(${r}, ${g}, ${b})`;
            }
            
            ctx.fillStyle = fillColor;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            if (grid.topology === 'square') {
                drawSquareCell(ctx, pos, grid.cellSize);
            } else {
                drawHexCell(ctx, pos, grid.cellSize);
            }
            
            if (cell.obstacle) {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('X', pos.x, pos.y);
            } else {
                ctx.fillStyle = value > 5 ? '#fff' : '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(value.toString(), pos.x, pos.y);
            }
        }

        function drawSquareCell(ctx, pos, size) {
            let halfSize = size / 2;
            ctx.fillRect(pos.x - halfSize, pos.y - halfSize, size, size);
            ctx.strokeRect(pos.x - halfSize, pos.y - halfSize, size, size);
        }

        function drawHexCell(ctx, pos, size) {
            let path = UGrid.pointyTop.createDrawPath(size);
            ctx.beginPath();
            ctx.moveTo(pos.x + path[0], pos.y + path[1]);
            for (let i = 2; i < path.length; i += 2) {
                ctx.lineTo(pos.x + path[i], pos.y + path[i + 1]);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function highlightCell(cell, color) {
            cell.highlighted = color;
        }

        function displayGridText() {
            if (!grid) return;
            
            let display = '';
            for (let y = 0; y < grid.rowCount; y++) {
                for (let x = 0; x < grid.colCount; x++) {
                    let cell = grid.get(x, y);
                    let value = cell && cell.value !== undefined ? cell.value : 0;
                    display += value.toString().padStart(2, ' ') + ' ';
                }
                display += '\n';
            }
            getElement('gridDisplay').innerHTML = `<pre>${display}</pre>`;
        }

        document.addEventListener('DOMContentLoaded', function() {
            createGrid();
            resetFlood();
        });
    </script>
</body>
</html>
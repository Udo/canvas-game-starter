var source = "struct BaseUniforms {\n  uOptions: vec4<f32>,\n  uCounts: vec2<f32>,\n};\n\nstruct StopsUniforms {\n  uColors: array<vec3<f32>, MAX_STOPS>,\n  uStops: array<vec4<f32>, MAX_STOPS>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> baseUniforms : BaseUniforms;\n@group(1) @binding(1) var<uniform> stopsUniforms : StopsUniforms;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>,\n  @location(1) coord : vec2<f32>\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn filterCoord( vTextureCoord:vec2<f32> ) -> vec2<f32>\n{\n    return vTextureCoord * gfu.uInputSize.xy / gfu.uOutputFrame.zw;\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  let vTextureCoord: vec2<f32> = filterTextureCoord(aPosition);\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   vTextureCoord,\n   filterCoord(vTextureCoord),\n  );\n}\n\nstruct ColorStop {\n  offset: f32,\n  color: vec3<f32>,\n  alpha: f32,\n};\n\nfn rotate2d(angle: f32) -> mat2x2<f32>{\n  return mat2x2(cos(angle), -sin(angle),\n  sin(angle), cos(angle));\n}\n\nfn projectLinearPosition(pos: vec2<f32>, angle: f32) -> f32 {\n  var center: vec2<f32> = vec2<f32>(0.5);\n  var result: vec2<f32> = pos - center;\n  result = rotate2d(angle) * result;\n  result = result + center;\n  return clamp(result.x, 0.0, 1.0);\n}\n\nfn projectRadialPosition(pos: vec2<f32>) -> f32 {\n  var r: f32 = distance(pos, vec2<f32>(0.5));\n  return clamp(2.0 * r, 0.0, 1.0);\n}\n\nfn projectAnglePosition(pos: vec2<f32>, angle: f32) -> f32 {\n  var center: vec2<f32> = pos - vec2<f32>(0.5, 0.5);\n  var polarAngle: f32 = atan2(-center.y, center.x);\n  return ((polarAngle + angle) % PI_2) / PI_2;\n}\n\nfn projectPosition(pos: vec2<f32>, gradientType: i32, angle: f32) -> f32 {\n  if (gradientType == TYPE_LINEAR) {\n      return projectLinearPosition(pos, angle);\n  } else if (gradientType == TYPE_RADIAL) {\n      return projectRadialPosition(pos);\n  } else if (gradientType == TYPE_CONIC) {\n      return projectAnglePosition(pos, angle);\n  }\n\n  return pos.y;\n}\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>,\n  @location(1) coord : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uType: i32 = i32(baseUniforms.uOptions[0]);\n  let uAngle: f32 = baseUniforms.uOptions[1];\n  let uAlpha: f32 = baseUniforms.uOptions[2];\n  let uReplace: f32 = baseUniforms.uOptions[3];\n\n  let uNumStops: i32 = i32(baseUniforms.uCounts[0]);\n  let uMaxColors: f32 = baseUniforms.uCounts[1];\n\n  // current/original color\n  var currentColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  // skip calculations if gradient alpha is 0\n  if (uAlpha == 0.0) { return currentColor; }\n\n  // project position\n  var y: f32 = projectPosition(coord, uType, radians(uAngle));\n\n  // check gradient bounds\n  var offsetMin: f32 = stopsUniforms.uStops[0][0];\n  var offsetMax: f32 = 0.0;\n\n  let numStops: i32 = uNumStops;\n\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\n      if (i == numStops - 1) { // last index\n          offsetMax = stopsUniforms.uStops[i][0];\n      }\n  }\n\n  if (y  < offsetMin || y > offsetMax) { return currentColor; }\n\n  // limit colors\n  if (uMaxColors > 0.0) {\n      var stepSize: f32 = 1.0 / uMaxColors;\n      var stepNumber: f32 = floor(y / stepSize);\n      y = stepSize * (stepNumber + 0.5); // offset by 0.5 to use color from middle of segment\n  }\n\n  // find color stops\n  var stopFrom: ColorStop;\n  var stopTo: ColorStop;\n\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\n      if (y >= stopsUniforms.uStops[i][0]) {\n          stopFrom = ColorStop(stopsUniforms.uStops[i][0], stopsUniforms.uColors[i], stopsUniforms.uStops[i][1]);\n          stopTo = ColorStop(stopsUniforms.uStops[i + 1][0], stopsUniforms.uColors[i + 1], stopsUniforms.uStops[i + 1][1]);\n      }\n\n      if (i == numStops - 1) { // last index\n          break;\n      }\n  }\n\n  // mix colors from stops\n  var colorFrom: vec4<f32> = vec4<f32>(stopFrom.color * stopFrom.alpha, stopFrom.alpha);\n  var colorTo: vec4<f32> = vec4<f32>(stopTo.color * stopTo.alpha, stopTo.alpha);\n\n  var segmentHeight: f32 = stopTo.offset - stopFrom.offset;\n  var relativePos: f32 = y - stopFrom.offset; // position from 0 to [segmentHeight]\n  var relativePercent: f32 = relativePos / segmentHeight; // position in percent between [from.offset] and [to.offset].\n\n  var gradientAlpha: f32 = uAlpha * currentColor.a;\n  var gradientColor: vec4<f32> = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\n\n  if (uReplace < 0.5) {\n      // mix resulting color with current color\n      return gradientColor + currentColor * (1.0 - gradientColor.a);\n  } else {\n      // replace with gradient color\n      return gradientColor;\n  }\n}\n\nconst PI: f32 = 3.14159265358979323846264;\nconst PI_2: f32 = PI * 2.0;\n\nconst TYPE_LINEAR: i32 = 0;\nconst TYPE_RADIAL: i32 = 1;\nconst TYPE_CONIC: i32 = 2;\nconst MAX_STOPS: i32 = 32;";

export { source as default };
//# sourceMappingURL=color-gradient3.mjs.map
